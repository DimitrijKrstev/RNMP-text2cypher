[
  {
    "question": "Which driver has the most career podiums (top-3 finishes)? Return driver and podiums.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS podiums\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY d.driverId\nORDER BY podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder <= 3\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has started the most Grands Prix (most races entered)? Return driver and races_started.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT(DISTINCT r.raceId) AS races_started\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY d.driverId\nORDER BY races_started DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the most poles overall? Return constructor and pole_count.",
    "sql": "SELECT c.name AS constructor, COUNT() AS pole_count\nFROM qualifying q\nJOIN constructors c ON c.constructorId = q.constructorId\nWHERE q.position = 1\nGROUP BY c.constructorId\nORDER BY pole_count DESC\nLIMIT 1;",
    "cypher": "MATCH (c:constructors), (q:qualifying), (q)-[:FOR_CONSTRUCTOR]->(c)\nWHERE q.position = 1\nRETURN c.name AS constructor, count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which driver set the most fastest laps (race fastest lap) in their career? Return driver and fastest_laps.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS fastest_laps\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.fastestLap > 0 -- assuming 0 or NULL means none\nGROUP BY d.driverId\nORDER BY fastest_laps DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which race (year, name) had the highest number of retirements (non-finished classified as non-finished)? Return year, name, retirements.",
    "sql": "SELECT ra.year, ra.name AS race, COUNT() AS retirements\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN status s ON s.statusId = r.statusId\nWHERE s.status != 'Finished'\nGROUP BY ra.raceId\nORDER BY retirements DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (ra:races), (res)-[:IN_RACE]->(ra)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status <> 'Finished') OR (exists(res.status) AND res.status <> 'Finished') )\nRETURN ra.name AS race, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the highest career average finish (consider only races they finished)? Return driver and avg_finish (2 decimals).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ROUND(AVG(r.positionOrder), 2) AS avg_finish\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nJOIN status s ON s.statusId = r.statusId\nWHERE s.status = 'Finished' AND r.positionOrder IS NOT NULL\nGROUP BY d.driverId\nHAVING COUNT() >= 10 -- filter to drivers with some sample size\nORDER BY avg_finish ASC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status = 'Finished') OR (exists(res.status) AND res.status = 'Finished') )\nRETURN d.forename + ' ' + d.surname AS driver, avg(res.positionOrder) AS avg_finish\nORDER BY avg_finish ASC\nLIMIT 1"
  },
  {
    "question": "Which constructor scored the most points in a single season? Return constructor, year, and points.",
    "sql": "WITH season_points AS (\n SELECT ra.year, r.constructorId, SUM(r.points) AS pts\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY ra.year, r.constructorId\n)\nSELECT c.name AS constructor, sp.year, sp.pts AS points\nFROM season_points sp\nJOIN constructors c ON c.constructorId = sp.constructorId\nORDER BY sp.pts DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN ra.year AS year, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver led the most laps in a single race (by lap count)? Return race (year, name), driver, and laps_led.",
    "sql": "-- Assumes a 'lap_leaders' or that lapsLed exists in results as lapsLed\nSELECT ra.year, ra.name AS race, d.forename || ' ' || d.surname AS driver, r.lapsLed AS laps_led\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.lapsLed IS NOT NULL\nORDER BY r.lapsLed DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most number of DNFs (did not finish)? Return driver and dnfs.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS dnfs\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nJOIN status s ON s.statusId = r.statusId\nWHERE s.status != 'Finished'\nGROUP BY d.driverId\nORDER BY dnfs DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status <> 'Finished') OR (exists(res.status) AND res.status <> 'Finished') )\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which circuit has hosted the most races? Return circuit and races_hosted.",
    "sql": "SELECT ci.name AS circuit, COUNT() AS races_hosted\nFROM races ra\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nGROUP BY ci.circuitId\nORDER BY races_hosted DESC\nLIMIT 1;",
    "cypher": "MATCH (ra:races), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nRETURN ci.name AS circuit, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the longest gap between first and last career race (career span in years)? Return driver, first_race_date, last_race_date, span_years (to 2 decimals).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, MIN(ra.date) AS first_race_date, MAX(ra.date) AS last_race_date, ROUND((julianday(MAX(ra.date)) - julianday(MIN(ra.date))) / 365.25, 2) AS span_years\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY d.driverId\nORDER BY span_years DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most pole positions in a single season? Return driver, year, and pole_count.",
    "sql": "WITH season_poles AS (\n SELECT ra.year, q.driverId, COUNT() AS poles\n FROM qualifying q\n JOIN races ra ON ra.raceId = q.raceId\n WHERE q.position = 1\n GROUP BY ra.year, q.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, sp.year, sp.poles AS pole_count\nFROM season_poles sp\nJOIN drivers d ON d.driverId = sp.driverId\nORDER BY sp.poles DESC, sp.year ASC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races), (q:qualifying), (q)-[:FOR_DRIVER]->(d), (q)-[:FOR_RACE]->(ra)\nWHERE q.position = 1\nRETURN ra.year AS year, count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the highest average points per race across its history (min 50 races)? Return constructor and avg_points_per_race (2 decimals).",
    "sql": "SELECT c.name AS constructor, ROUND(SUM(r.points) * 1.0 / COUNT(DISTINCT r.raceId), 2) AS avg_points_per_race\nFROM results r\nJOIN constructors c ON c.constructorId = r.constructorId\nGROUP BY c.constructorId\nHAVING COUNT(DISTINCT r.raceId) >= 50\nORDER BY avg_points_per_race DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c)\nRETURN c.name AS constructor, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most consecutive race wins (longest win streak)? Return driver, streak_length, start_race_id, end_race_id.",
    "sql": "-- This uses a gaps-and-islands approach assuming raceId increments in chronological order\nWITH wins AS (\n SELECT ra.date, ra.raceId, r.driverId, ROW_NUMBER() OVER (ORDER BY ra.date) AS rn\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n WHERE r.positionOrder = 1\n), grp AS (\n SELECT w., DATE(w.date) AS race_date, (ROW_NUMBER() OVER (PARTITION BY w.driverId ORDER BY w.date) - ROW_NUMBER() OVER (ORDER BY w.date)) AS grp_id\n FROM wins w\n)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS streak_length, MIN(raceId) AS start_race_id, MAX(raceId) AS end_race_id\nFROM grp g\nJOIN drivers d ON d.driverId = g.driverId\nGROUP BY g.driverId, g.grp_id\nORDER BY streak_length DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the best average qualifying position (min 20 qualifying attempts)? Return driver and avg_qual_pos (2 decimals).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ROUND(AVG(q.position), 2) AS avg_qual_pos\nFROM qualifying q\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position IS NOT NULL\nGROUP BY d.driverId\nHAVING COUNT() >= 20\nORDER BY avg_qual_pos ASC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (q:qualifying), (q)-[:FOR_DRIVER]->(d)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver scored points in the most consecutive races? Return driver and consecutive_point_races.",
    "sql": "WITH points_flag AS (\n SELECT r.raceId, r.driverId, CASE WHEN r.points > 0 THEN 1 ELSE 0 END AS scored\n FROM results r\n), seq AS (\n SELECT pf., ROW_NUMBER() OVER (PARTITION BY pf.driverId ORDER BY pf.raceId) AS rn1, ROW_NUMBER() OVER (PARTITION BY pf.driverId, pf.scored ORDER BY pf.raceId) AS rn2\n FROM points_flag pf\n)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS consecutive_point_races\nFROM seq s\nJOIN drivers d ON d.driverId = s.driverId\nWHERE s.scored = 1\nGROUP BY s.driverId, (s.rn1 - s.rn2)\nORDER BY consecutive_point_races DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.points > 0\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the most different teams (constructors) raced for in their career? Return driver and constructor_count.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT(DISTINCT r.constructorId) AS constructor_count\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY d.driverId\nORDER BY constructor_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the highest single-season points per race (min 5 races in season)? Return driver, year, avg_points_per_race (2 decimals).",
    "sql": "WITH season_stats AS (\n SELECT ra.year, r.driverId, SUM(r.points) AS pts, COUNT() AS races\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY ra.year, r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, ss.year, ROUND(ss.pts * 1.0 / ss.races, 2) AS avg_points_per_race\nFROM season_stats ss\nJOIN drivers d ON d.driverId = ss.driverId\nWHERE ss.races >= 5\nORDER BY avg_points_per_race DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN ra.year AS year, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most season championships (driver titles) if available in 'driverStandings' table? Return driver and titles.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS titles\nFROM driverStandings ds\nJOIN drivers d ON d.driverId = ds.driverId\nWHERE ds.position = 1\nGROUP BY ds.driverId\nORDER BY titles DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ds:driverStandings), (ds)-[:FOR_DRIVER]->(d)\nWHERE ds.position = 1\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the best reliability in a single season (fewest retirements per race, min 10 races)? Return constructor, year, retirements_per_race (3 decimals).",
    "sql": "WITH ctor_season AS (\n SELECT ra.year, r.constructorId, SUM(CASE WHEN s.status != 'Finished' THEN 1 ELSE 0 END) AS retires, COUNT() AS entries\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n JOIN status s ON s.statusId = r.statusId\n GROUP BY ra.year, r.constructorId\n)\nSELECT c.name AS constructor, cs.year, ROUND(cs.retires * 1.0 / cs.entries, 3) AS retirements_per_race\nFROM ctor_season cs\nJOIN constructors c ON c.constructorId = cs.constructorId\nWHERE cs.entries >= 10\nORDER BY retirements_per_race ASC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status <> 'Finished') OR (exists(res.status) AND res.status <> 'Finished') )\nRETURN ra.year AS year, count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the fastest single lap in history (minimum lapTimes.milliseconds)? Return driver, race (year, name), lap_ms.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ra.year, ra.name AS race, lt.milliseconds AS lap_ms\nFROM lapTimes lt\nJOIN drivers d ON d.driverId = lt.driverId\nJOIN races ra ON ra.raceId = lt.raceId\nORDER BY lt.milliseconds ASC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races)\nRETURN count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the most podiums in a single season? Return driver, year, and podiums.",
    "sql": "WITH season_podiums AS (\n SELECT ra.year, r.driverId, COUNT() AS podiums\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n WHERE r.positionOrder <= 3\n GROUP BY ra.year, r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, sp.year, sp.podiums\nFROM season_podiums sp\nJOIN drivers d ON d.driverId = sp.driverId\nORDER BY sp.podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder <= 3\nRETURN ra.year AS year, count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most wins without ever having been champion (no season with position=1 in driverStandings)? Return driver and wins.",
    "sql": "WITH champions AS (SELECT DISTINCT driverId FROM driverStandings WHERE position = 1)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS wins\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nLEFT JOIN champions ch ON ch.driverId = d.driverId\nWHERE r.positionOrder = 1 AND ch.driverId IS NULL\nGROUP BY d.driverId\nORDER BY wins DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ds:driverStandings), (ds)-[:FOR_DRIVER]->(d)\nWHERE res.positionOrder = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has won on the most different countries (count distinct race country)? Return constructor and countries_won.",
    "sql": "SELECT c.name AS constructor, COUNT(DISTINCT ra.country) AS countries_won\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN constructors c ON c.constructorId = r.constructorId\nWHERE r.positionOrder = 1\nGROUP BY c.constructorId\nORDER BY countries_won DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN c.name AS constructor, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the highest win percentage (wins / starts) with at least 20 starts? Return driver and win_pct (4 decimals).",
    "sql": "WITH starts AS (\n SELECT r.driverId, COUNT() AS starts\n FROM results r\n GROUP BY r.driverId\n), wins AS (\n SELECT r.driverId, COUNT() AS wins\n FROM results r\n WHERE r.positionOrder = 1\n GROUP BY r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, ROUND(COALESCE(w.wins,0) * 1.0 / s.starts, 4) AS win_pct\nFROM starts s\nLEFT JOIN wins w ON w.driverId = s.driverId\nJOIN drivers d ON d.driverId = s.driverId\nWHERE s.starts >= 20\nORDER BY win_pct DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most fastest laps in a single season? Return driver, year, fastest_laps.",
    "sql": "WITH season_fastest AS (\n SELECT ra.year, r.driverId, COUNT() AS fls\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n WHERE r.fastestLap > 0\n GROUP BY ra.year, r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, sf.year, sf.fls AS fastest_laps\nFROM season_fastest sf\nJOIN drivers d ON d.driverId = sf.driverId\nORDER BY sf.fls DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN ra.year AS year, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the most podiums without a win in a season? Return driver, year, podiums.",
    "sql": "WITH season_stats AS (\n SELECT ra.year, r.driverId, SUM(CASE WHEN r.positionOrder <= 3 THEN 1 ELSE 0 END) AS podiums, SUM(CASE WHEN r.positionOrder = 1 THEN 1 ELSE 0 END) AS wins\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY ra.year, r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, ss.year, ss.podiums\nFROM season_stats ss\nJOIN drivers d ON d.driverId = ss.driverId\nWHERE ss.wins = 0 AND ss.podiums > 0\nORDER BY ss.podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder <= 3 AND res.positionOrder = 1\nRETURN ra.year AS year, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the earliest first career race (oldest historical debut)? Return driver and first_race_date.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, MIN(ra.date) AS first_race_date\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY d.driverId\nORDER BY first_race_date ASC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver scored the most points at a single circuit across their career? Return driver, circuit, and points.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ci.name AS circuit, SUM(r.points) AS points\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY r.driverId, ra.circuitId\nORDER BY points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nRETURN sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the most 1-2 finishes in a single race (both constructors' drivers finishing 1st and 2nd)? Return race (year, name), constructor, and count_1_2 (should be 1 or number of constructors achieving 1-2).",
    "sql": "-- Find constructors that scored 1st and 2nd in the same race\nWITH top2 AS (\n SELECT r.raceId, r.positionOrder, r.constructorId\n FROM results r\n WHERE r.positionOrder IN (1,2)\n), grouped AS (\n SELECT raceId, constructorId, COUNT() AS cnt\n FROM top2\n GROUP BY raceId, constructorId\n HAVING COUNT() = 2\n)\nSELECT ra.year, ra.name AS race, c.name AS constructor, 2 AS count_1_2\nFROM grouped g\nJOIN races ra ON ra.raceId = g.raceId\nJOIN constructors c ON c.constructorId = g.constructorId\nORDER BY ra.year DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the biggest single-season improvement in points compared to previous season? Return driver, from_year, to_year, points_delta.",
    "sql": "WITH driver_season AS (\n SELECT ra.year, r.driverId, SUM(r.points) AS pts\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY ra.year, r.driverId\n), deltas AS (\n SELECT ds1.driverId, ds1.year AS from_year, ds2.year AS to_year, (ds2.pts - ds1.pts) AS delta\n FROM driver_season ds1\n JOIN driver_season ds2 ON ds2.driverId = ds1.driverId AND ds2.year = ds1.year + 1\n)\nSELECT d.forename || ' ' || d.surname AS driver, del.from_year, del.to_year, del.delta AS points_delta\nFROM deltas del\nJOIN drivers d ON d.driverId = del.driverId\nORDER BY del.delta DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN ra.year AS year, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver/constructor pair has the most wins together? Return driver, constructor, and wins_together.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, c.name AS constructor, COUNT() AS wins_together\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nJOIN constructors c ON c.constructorId = r.constructorId\nWHERE r.positionOrder = 1\nGROUP BY r.driverId, r.constructorId\nORDER BY wins_together DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the most points in a single race (highest points earned by a driver in one race)? Return race (year, name), driver, and points.",
    "sql": "SELECT ra.year, ra.name AS race, d.forename || ' ' || d.surname AS driver, r.points\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nORDER BY r.points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most seasons with at least one win? Return driver and seasons_with_win.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT(DISTINCT ra.year) AS seasons_with_win\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 1\nGROUP BY d.driverId\nORDER BY seasons_with_win DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which circuit has seen the most different winners? Return circuit and distinct_winners_count.",
    "sql": "SELECT ci.name AS circuit, COUNT(DISTINCT r.driverId) AS distinct_winners_count\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nWHERE r.positionOrder = 1\nGROUP BY ci.circuitId\nORDER BY distinct_winners_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nWHERE res.positionOrder = 1\nRETURN ci.name AS circuit, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which season had the highest average number of retirements per race? Return year and avg_retirements (2 decimals).",
    "sql": "SELECT ra.year, ROUND(AVG(ret.retirements), 2) AS avg_retirements\nFROM (\n SELECT r.raceId, SUM(CASE WHEN s.status != 'Finished' THEN 1 ELSE 0 END) AS retirements\n FROM results r\n JOIN status s ON s.statusId = r.statusId\n GROUP BY r.raceId\n) ret\nJOIN races ra ON ra.raceId = ret.raceId\nGROUP BY ra.year\nORDER BY avg_retirements DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (ra:races), (res)-[:IN_RACE]->(ra)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status <> 'Finished') OR (exists(res.status) AND res.status <> 'Finished') )\nRETURN ra.year AS year, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most podiums at a single circuit? Return driver, circuit, and podiums.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ci.name AS circuit, COUNT() AS podiums\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY r.driverId, ra.circuitId\nORDER BY podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nWHERE res.positionOrder <= 3\nRETURN count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most points scored from fastest laps (if points for fastest lap exist in points column or separate)? Return driver and count_fastestlap_points.",
    "sql": "-- Assumes points for fastest lap are included in r.points and flag fastestLapPoints exists; fallback: count of fastest laps\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS fastest_laps\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.fastestLap > 0\nGROUP BY d.driverId\nORDER BY fastest_laps DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most podiums without a win in their career? Return driver and podiums_no_win.",
    "sql": "WITH wins AS (SELECT DISTINCT driverId FROM results WHERE positionOrder = 1)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS podiums_no_win\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nLEFT JOIN wins w ON w.driverId = r.driverId\nWHERE r.positionOrder <= 3 AND w.driverId IS NULL\nGROUP BY r.driverId\nORDER BY podiums_no_win DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder <= 3\nRETURN count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which race weekend had the highest total number of pit stops across all drivers? Return race (year, name) and total_pitstops.",
    "sql": "SELECT ra.year, ra.name AS race, COUNT() AS total_pitstops\nFROM pitStops p\nJOIN races ra ON ra.raceId = p.raceId\nGROUP BY p.raceId\nORDER BY total_pitstops DESC\nLIMIT 1;",
    "cypher": "MATCH (ra:races)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most top-10 finishes in their career? Return driver and top10_count.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS top10_count\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 10\nGROUP BY d.driverId\nORDER BY top10_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder <= 10\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the highest single-race points haul (sum of points for both team drivers in one race)? Return race (year, name), constructor, and points_sum.",
    "sql": "SELECT ra.year, ra.name AS race, c.name AS constructor, SUM(r.points) AS points_sum\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN constructors c ON c.constructorId = r.constructorId\nGROUP BY ra.raceId, r.constructorId\nORDER BY points_sum DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN ra.name AS race, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the most podiums across a single season without winning the title? Return driver, year, podiums.",
    "sql": "WITH season_podiums AS (\n SELECT ra.year, r.driverId, COUNT(CASE WHEN r.positionOrder <= 3 THEN 1 END) AS podiums\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY ra.year, r.driverId\n), champions AS (SELECT year, driverId FROM driverStandings WHERE position = 1)\nSELECT d.forename || ' ' || d.surname AS driver, sp.year, sp.podiums\nFROM season_podiums sp\nLEFT JOIN champions ch ON ch.year = sp.year AND ch.driverId = sp.driverId\nJOIN drivers d ON d.driverId = sp.driverId\nWHERE ch.driverId IS NULL\nORDER BY sp.podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (ds:driverStandings), (ds)-[:FOR_DRIVER]->(d), (ds)-[:IN_RACE]->(ra)\nWHERE res.positionOrder <= 3\nRETURN ra.year AS year, count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the most points in qualifying (if qualifying awards points) or the most poles in career? Return driver and poles (as proxy).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS poles\nFROM qualifying q\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position = 1\nGROUP BY d.driverId\nORDER BY poles DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (q:qualifying), (q)-[:FOR_DRIVER]->(d)\nWHERE q.position = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the largest single-race improvement from their fastest lap compared to field average (biggest negative deviation)? Return race (year, name), driver, and diff_ms.",
    "sql": "-- Approximation: compare driver's best lap to average best lap in race\nWITH bestlaps AS (\n SELECT lt.raceId, lt.driverId, MIN(lt.milliseconds) AS best_ms\n FROM lapTimes lt\n GROUP BY lt.raceId, lt.driverId\n), race_avg AS (\n SELECT raceId, AVG(best_ms) AS avg_best_ms\n FROM bestlaps\n GROUP BY raceId\n)\nSELECT ra.year, ra.name AS race, d.forename || ' ' || d.surname AS driver, ROUND((b.best_ms - raavg.avg_best_ms), 2) AS diff_ms\nFROM bestlaps b\nJOIN race_avg raavg ON raavg.raceId = b.raceId\nJOIN races ra ON ra.raceId = b.raceId\nJOIN drivers d ON d.driverId = b.driverId\nORDER BY diff_ms ASC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races)\nRETURN count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most different teammates across their career (count distinct teammate drivers per season/constructor)? Return driver and teammate_count.",
    "sql": "-- Teammates defined by sharing constructorId in same race/year; approximate by same race\nWITH team_pairs AS (\n SELECT r1.driverId AS driver, r2.driverId AS teammate\n FROM results r1\n JOIN results r2 ON r1.raceId = r2.raceId AND r1.constructorId = r2.constructorId\n WHERE r1.driverId != r2.driverId\n GROUP BY r1.driverId, r2.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS teammate_count\nFROM team_pairs tp\nJOIN drivers d ON d.driverId = tp.driver\nGROUP BY tp.driver\nORDER BY teammate_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver improved the most positions on average from grid to finish (min 30 races)? Return driver and avg_gain (2 decimals).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ROUND(AVG(CASE WHEN r.grid IS NOT NULL AND r.positionOrder IS NOT NULL THEN (r.grid - r.positionOrder) ELSE 0 END), 2) AS avg_gain\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY d.driverId\nHAVING COUNT() >= 30\nORDER BY avg_gain DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most pole-to-win conversions (won the race after starting from pole)? Return driver and conversions.",
    "sql": "WITH poles AS (SELECT raceId, driverId FROM qualifying WHERE position = 1)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS conversions\nFROM poles p\nJOIN results r ON r.raceId = p.raceId AND r.driverId = p.driverId AND r.positionOrder = 1\nJOIN drivers d ON d.driverId = p.driverId\nGROUP BY p.driverId\nORDER BY conversions DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (q:qualifying), (q)-[:FOR_DRIVER]->(d)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the most appearances in the points without ever winning a race? Return driver and points_finishes.",
    "sql": "WITH winners AS (SELECT DISTINCT driverId FROM results WHERE positionOrder = 1)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS points_finishes\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nLEFT JOIN winners w ON w.driverId = r.driverId\nWHERE r.points > 0 AND w.driverId IS NULL\nGROUP BY r.driverId\nORDER BY points_finishes DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.points > 0\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the fastest average lap across all laps in career (min 500 laps)? Return driver and avg_lap_ms (2 decimals).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ROUND(AVG(lt.milliseconds), 2) AS avg_lap_ms\nFROM lapTimes lt\nJOIN drivers d ON d.driverId = lt.driverId\nGROUP BY lt.driverId\nHAVING COUNT() >= 500\nORDER BY avg_lap_ms ASC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers)\nRETURN count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which constructor finished 1-2-3 (podium sweep) most times in history? Return constructor and sweep_count.",
    "sql": "-- Count races where top3 all same constructor\nWITH top3 AS (\n SELECT r.raceId, r.positionOrder, r.constructorId\n FROM results r\n WHERE r.positionOrder IN (1,2,3)\n), grouped AS (\n SELECT raceId, COUNT(DISTINCT constructorId) AS distinct_ctors, MIN(constructorId) AS ctorId\n FROM top3\n GROUP BY raceId\n HAVING COUNT() = 3 AND COUNT(DISTINCT constructorId) = 1\n)\nSELECT c.name AS constructor, COUNT() AS sweep_count\nFROM grouped g\nJOIN constructors c ON c.constructorId = g.ctorId\nGROUP BY g.ctorId\nORDER BY sweep_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most finishes in P2 (second place) in their career? Return driver and second_places.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS second_places\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 2\nGROUP BY d.driverId\nORDER BY second_places DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder = 2\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which team (constructor) introduced the most different chassis/models (if constructors table has 'name' only, use distinct constructorRef) \u2014 approximate by constructorRef changes? Return constructor and model_count.",
    "sql": "-- If constructors table has constructorRef or similar; fallback to count distinct names (not ideal)\nSELECT c.name AS constructor, COUNT(DISTINCT c.constructorRef) AS model_count\nFROM constructors c\nGROUP BY c.name\nORDER BY model_count DESC\nLIMIT 1;",
    "cypher": "MATCH (c:constructors)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the most points in a debut race? Return driver, race (year, name), and points.",
    "sql": "WITH debut AS (\n SELECT r.driverId, MIN(ra.date) AS first_date\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, ra.year, ra.name AS race, r.points\nFROM debut db\nJOIN races ra ON ra.date = db.first_date\nJOIN results r ON r.driverId = db.driverId AND r.raceId = ra.raceId\nJOIN drivers d ON d.driverId = db.driverId\nORDER BY r.points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most appearances in the top-5 without ever winning a race? Return driver and top5_count.",
    "sql": "WITH winners AS (SELECT DISTINCT driverId FROM results WHERE positionOrder = 1)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS top5_count\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nLEFT JOIN winners w ON w.driverId = r.driverId\nWHERE r.positionOrder <= 5 AND w.driverId IS NULL\nGROUP BY r.driverId\nORDER BY top5_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder <= 5\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which race had the smallest margin of victory (if margin data exists) or the smallest gap between 1st and 2nd fastest lap? Return race (year, name) and margin_ms.",
    "sql": "-- Use fastest lap difference as proxy if winning margin not available\nWITH winner_fast AS (\n SELECT lt.raceId, lt.driverId, MIN(lt.milliseconds) AS best_ms\n FROM lapTimes lt\n GROUP BY lt.raceId, lt.driverId\n), ordered AS (\n SELECT wf.raceId, wf.driverId, wf.best_ms, ROW_NUMBER() OVER (PARTITION BY wf.raceId ORDER BY wf.best_ms) AS rn\n FROM winner_fast wf\n)\nSELECT ra.year, ra.name AS race, ROUND((o2.best_ms - o1.best_ms),2) AS margin_ms\nFROM ordered o1\nJOIN ordered o2 ON o1.raceId = o2.raceId AND o1.rn = 1 AND o2.rn = 2\nJOIN races ra ON ra.raceId = o1.raceId\nORDER BY margin_ms ASC\nLIMIT 1;",
    "cypher": "MATCH (ra:races)\nRETURN count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver scored the most points at their home country races (sum points where race.country matches driver's nationality)? Return driver and home_points.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, SUM(r.points) AS home_points\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE LOWER(ra.country) LIKE LOWER('%' || d.nationality || '%') OR ra.country = d.nationality\nGROUP BY d.driverId\nORDER BY home_points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN d.forename + ' ' + d.surname AS driver, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the most podiums in their rookie season? Return driver, year, and podiums_rookie.",
    "sql": "WITH first_year AS (\n SELECT r.driverId, MIN(ra.year) AS first_year\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, fy.first_year AS year, COUNT() AS podiums_rookie\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN first_year fy ON fy.driverId = r.driverId AND ra.year = fy.first_year\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY r.driverId, fy.first_year\nORDER BY podiums_rookie DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder <= 3\nRETURN count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which circuit produced the most unexpected winners (winners whose grid position >= 10)? Return circuit and unexpected_wins.",
    "sql": "SELECT ci.name AS circuit, COUNT() AS unexpected_wins\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nWHERE r.positionOrder = 1 AND r.grid >= 10\nGROUP BY ci.circuitId\nORDER BY unexpected_wins DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nWHERE res.positionOrder = 1 AND res.grid >= 10\nRETURN ci.name AS circuit, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver led the championship for the most race weekends in a single season? Return driver, year, and weekends_led (count of rounds where they were championship leader after race).",
    "sql": "-- Requires driverStandings by round; approximate by driverStandings table with round-level data\nSELECT d.forename || ' ' || d.surname AS driver, ds.year, COUNT() AS weekends_led\nFROM driverStandings ds\nJOIN drivers d ON d.driverId = ds.driverId\nWHERE ds.position = 1\nGROUP BY ds.driverId, ds.year\nORDER BY weekends_led DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ds:driverStandings), (ds)-[:FOR_DRIVER]->(d)\nWHERE ds.position = 1\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most pole positions at a single circuit? Return driver, circuit, and poles.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ci.name AS circuit, COUNT() AS poles\nFROM qualifying q\nJOIN races ra ON ra.raceId = q.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position = 1\nGROUP BY q.driverId, ra.circuitId\nORDER BY poles DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races), (ci:circuits), (ra)-[:HELD_AT]->(ci), (q:qualifying), (q)-[:FOR_DRIVER]->(d), (q)-[:FOR_RACE]->(ra)\nWHERE q.position = 1\nRETURN count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the most seasons with at least one win? Return constructor and seasons_with_win.",
    "sql": "SELECT c.name AS constructor, COUNT(DISTINCT ra.year) AS seasons_with_win\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN constructors c ON c.constructorId = r.constructorId\nWHERE r.positionOrder = 1\nGROUP BY c.constructorId\nORDER BY seasons_with_win DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN c.name AS constructor, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver scored points in the most different circuits? Return driver and distinct_circuits_points.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT(DISTINCT ra.circuitId) AS distinct_circuits_points\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.points > 0\nGROUP BY d.driverId\nORDER BY distinct_circuits_points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.points > 0\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most pole positions without ever winning a championship? Return driver and poles.",
    "sql": "WITH champs AS (SELECT DISTINCT driverId FROM driverStandings WHERE position = 1)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS poles\nFROM qualifying q\nJOIN drivers d ON d.driverId = q.driverId\nLEFT JOIN champs ch ON ch.driverId = q.driverId\nWHERE q.position = 1 AND ch.driverId IS NULL\nGROUP BY q.driverId\nORDER BY poles DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (q:qualifying), (q)-[:FOR_DRIVER]->(d), (ds:driverStandings), (ds)-[:FOR_DRIVER]->(d)\nWHERE q.position = 1\nRETURN count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most seasons with at least one podium? Return driver and seasons_with_podium.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT(DISTINCT ra.year) AS seasons_with_podium\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY d.driverId\nORDER BY seasons_with_podium DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder <= 3\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the most points from a single pit strategy (most points after making exactly 1 pit stop in the race)? Return race (year, name), driver, pitstops, points.",
    "sql": "-- Approx: count pitStops per race/driver then sum where pitcount = 1\nWITH pit_counts AS (\n SELECT p.raceId, p.driverId, COUNT() AS pitcount\n FROM pitStops p\n GROUP BY p.raceId, p.driverId\n)\nSELECT ra.year, ra.name AS race, d.forename || ' ' || d.surname AS driver, pc.pitcount AS pitstops, r.points\nFROM pit_counts pc\nJOIN results r ON r.raceId = pc.raceId AND r.driverId = pc.driverId\nJOIN races ra ON ra.raceId = pc.raceId\nJOIN drivers d ON d.driverId = pc.driverId\nWHERE pc.pitcount = 1\nORDER BY r.points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most fastest laps at a single circuit? Return driver, circuit, and fastest_laps_count.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ci.name AS circuit, COUNT() AS fastest_laps_count\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.fastestLap > 0\nGROUP BY r.driverId, ra.circuitId\nORDER BY fastest_laps_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most different co-drivers (co-starters in same race) across their career? Return driver and distinct_codrivers.",
    "sql": "WITH codr AS (\n SELECT r1.driverId AS driver, r2.driverId AS codriver\n FROM results r1\n JOIN results r2 ON r1.raceId = r2.raceId\n WHERE r1.driverId != r2.driverId\n GROUP BY r1.driverId, r2.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS distinct_codrivers\nFROM codr c\nJOIN drivers d ON d.driverId = c.driver\nGROUP BY c.driver\nORDER BY distinct_codrivers DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the highest average points per start across career (min 50 starts)? Return driver and avg_points_start (3 decimals).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ROUND(SUM(r.points) * 1.0 / COUNT(), 3) AS avg_points_start\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY r.driverId\nHAVING COUNT() >= 50\nORDER BY avg_points_start DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver gained the most positions in a single lap (if lapPositions table exists) \u2014 otherwise approximate by comparing consecutive lapTimes? Return race (year, name), driver, lap, gain.",
    "sql": "-- Approximation not possible without lap position table; fallback: largest single-race grid-to-finish gain already provided earlier\nWITH finished AS (\n SELECT r., s.status\n FROM results r\n JOIN status s ON s.statusId = r.statusId\n WHERE s.status = 'Finished' AND r.grid IS NOT NULL AND r.positionOrder IS NOT NULL\n), gains AS (\n SELECT f.raceId, f.driverId, f.grid, f.positionOrder AS finish, (f.grid - f.positionOrder) AS gain\n FROM finished f\n WHERE f.grid > f.positionOrder\n)\nSELECT ra.year, ra.name AS race, d.forename || ' ' || d.surname AS driver, g.grid, g.finish, g.gain\nFROM gains g\nJOIN races ra ON ra.raceId = g.raceId\nJOIN drivers d ON d.driverId = g.driverId\nORDER BY g.gain DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status = 'Finished') OR (exists(res.status) AND res.status = 'Finished') )\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has converted the most top-10 qualifying positions into top-10 finishes (best qualifying -> race consistency)? Return driver and conversions.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS conversions\nFROM qualifying q\nJOIN results r ON r.raceId = q.raceId AND r.driverId = q.driverId\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position <= 10 AND r.positionOrder <= 10\nGROUP BY q.driverId\nORDER BY conversions DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (q:qualifying), (q)-[:FOR_DRIVER]->(d)\nWHERE res.positionOrder <= 10 AND q.position <= 10\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most pole positions at their national Grand Prix (home race)? Return driver and poles_home.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS poles_home\nFROM qualifying q\nJOIN races ra ON ra.raceId = q.raceId\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position = 1 AND (LOWER(ra.country) LIKE LOWER('%' || d.nationality || '%') OR ra.country = d.nationality)\nGROUP BY d.driverId\nORDER BY poles_home DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races), (q:qualifying), (q)-[:FOR_DRIVER]->(d), (q)-[:FOR_RACE]->(ra)\nWHERE q.position = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most points in a calendar month across all years (sum points for races held in same month number)? Return month (1-12) and points.",
    "sql": "SELECT CAST(STRFTIME('%m', ra.date) AS INTEGER) AS month, SUM(r.points) AS points\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nGROUP BY month\nORDER BY points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the most wins at one circuit without ever having won at another circuit (i.e., concentrated success)? Return driver, circuit, and wins_at_circuit.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ci.name AS circuit, COUNT() AS wins_at_circuit\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 1\nGROUP BY r.driverId, ra.circuitId\nORDER BY wins_at_circuit DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver achieved the most fastest laps in the first half of their career (from debut to midpoint of career races)? Return driver and fastest_first_half.",
    "sql": "-- Complex; approximate by counting fastest laps in first N/2 races per driver.\nWITH driver_races AS (\n SELECT r.driverId, ra.date, r.raceId, ROW_NUMBER() OVER (PARTITION BY r.driverId ORDER BY ra.date) AS rn, COUNT() OVER (PARTITION BY r.driverId) AS total\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n), first_half AS (\n SELECT dr.driverId, dr.raceId\n FROM driver_races dr\n WHERE dr.rn <= CEIL(dr.total / 2.0)\n)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS fastest_first_half\nFROM first_half fh\nJOIN results r ON r.raceId = fh.raceId AND r.driverId = fh.driverId\nJOIN drivers d ON d.driverId = fh.driverId\nWHERE r.fastestLap > 0\nGROUP BY fh.driverId\nORDER BY fastest_first_half DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the best record in wet races (if 'weather' or 'race' has wet flag) \u2014 fallback: most wins in races with 'rain' in name/notes? Return driver and wet_wins.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS wet_wins\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 1 AND (LOWER(ra.name) LIKE '%rain%' OR LOWER(ra.name) LIKE '%wet%')\nGROUP BY d.driverId\nORDER BY wet_wins DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most consecutive points-scoring seasons? Return driver and consecutive_seasons.",
    "sql": "WITH season_points AS (\n SELECT ra.year, r.driverId, SUM(r.points) AS pts\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY ra.year, r.driverId\n), seasons_flag AS (\n SELECT sp.driverId, sp.year, CASE WHEN sp.pts > 0 THEN 1 ELSE 0 END AS scored\n FROM season_points sp\n), seq AS (\n SELECT sf., ROW_NUMBER() OVER (PARTITION BY sf.driverId ORDER BY sf.year) AS rn\n FROM seasons_flag sf\n)\nSELECT d.forename || ' ' || d.surname AS driver, MAX(consec.count_seasons) AS consecutive_seasons\nFROM (\n SELECT driverId, year, (ROW_NUMBER() OVER (PARTITION BY driverId ORDER BY year) - ROW_NUMBER() OVER (PARTITION BY driverId, scored ORDER BY year)) grp\n FROM seasons_flag\n) grouped\nJOIN (\n SELECT driverId, COUNT() AS count_seasons\n FROM (\n SELECT driverId, year, scored, (ROW_NUMBER() OVER (PARTITION BY driverId ORDER BY year) - ROW_NUMBER() OVER (PARTITION BY driverId, scored ORDER BY year)) grp\n FROM seasons_flag\n ) t\n WHERE scored = 1\n GROUP BY driverId, grp\n) consec ON consec.driverId = grouped.driverId\nJOIN drivers d ON d.driverId = consec.driverId\nGROUP BY consec.driverId\nORDER BY consecutive_seasons DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN ra.year AS year, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which circuit produced the closest average podium finish times (i.e., most competitive) approximated by smallest average winner-second fastest lap difference? Return circuit and avg_diff_ms.",
    "sql": "WITH bestlaps AS (\n SELECT lt.raceId, lt.driverId, MIN(lt.milliseconds) AS best_ms\n FROM lapTimes lt\n GROUP BY lt.raceId, lt.driverId\n), race_diff AS (\n SELECT b.raceId, (MIN(CASE WHEN rn=2 THEN best_ms END) - MIN(CASE WHEN rn=1 THEN best_ms END)) AS diff\n FROM (\n SELECT bl., ROW_NUMBER() OVER (PARTITION BY bl.raceId ORDER BY bl.best_ms) AS rn\n FROM bestlaps bl\n ) bl2\n GROUP BY b.raceId\n)\nSELECT ci.name AS circuit, ROUND(AVG(rd.diff),2) AS avg_diff_ms\nFROM race_diff rd\nJOIN races ra ON ra.raceId = rd.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nWHERE rd.diff IS NOT NULL\nGROUP BY ci.circuitId\nORDER BY avg_diff_ms ASC\nLIMIT 1;",
    "cypher": "MATCH (ra:races), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nRETURN ci.name AS circuit, count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver scored the most points after starting outside top-10? Return driver and points_from_outside_top10.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, SUM(r.points) AS points_from_outside_top10\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.grid > 10\nGROUP BY r.driverId\nORDER BY points_from_outside_top10 DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.grid > 10\nRETURN sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most wins in wet conditions where race name contains 'rain' or 'wet'? Return driver and wet_wins (same as earlier but ensure distinct).",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS wet_wins\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 1 AND (LOWER(ra.name) LIKE '%rain%' OR LOWER(ra.name) LIKE '%wet%')\nGROUP BY d.driverId\nORDER BY wet_wins DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most pole positions in their rookie season? Return driver, year, and poles_rookie.",
    "sql": "WITH first_year AS (\n SELECT r.driverId, MIN(ra.year) AS first_year\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n GROUP BY r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, fy.first_year AS year, COUNT() AS poles_rookie\nFROM qualifying q\nJOIN races ra ON ra.raceId = q.raceId\nJOIN first_year fy ON fy.driverId = q.driverId AND ra.year = fy.first_year\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position = 1\nGROUP BY q.driverId, fy.first_year\nORDER BY poles_rookie DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (q:qualifying), (q)-[:FOR_DRIVER]->(d), (q)-[:FOR_RACE]->(ra)\nWHERE q.position = 1\nRETURN count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which driver scored the most consecutive wins in a single season? Return driver, year, and streak_length.",
    "sql": "WITH season_wins AS (\n SELECT ra.year, r.driverId, ra.date, r.raceId\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n WHERE r.positionOrder = 1\n), grp AS (\n SELECT sw., ROW_NUMBER() OVER (PARTITION BY sw.driverId, sw.year ORDER BY sw.date) rn1, ROW_NUMBER() OVER (ORDER BY sw.date) rn2\n FROM season_wins sw\n)\nSELECT d.forename || ' ' || d.surname AS driver, grp.year, COUNT() AS streak_length\nFROM (\n SELECT driverId, year, (rn1 - rn2) AS grp_id\n FROM grp\n) g2\nJOIN season_wins sw ON sw.driverId = g2.driverId AND sw.year = g2.year\nJOIN drivers d ON d.driverId = g2.driverId\nGROUP BY g2.driverId, g2.year, g2.grp_id\nORDER BY streak_length DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the best record (highest win rate) at a specific circuit with at least 5 starts at that circuit? Return driver, circuit, and win_rate.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ci.name AS circuit, ROUND(SUM(CASE WHEN r.positionOrder=1 THEN 1 ELSE 0 END)1.0/COUNT(),3) AS win_rate\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY r.driverId, ra.circuitId\nHAVING COUNT() >= 5\nORDER BY win_rate DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nWHERE res.positionOrder = 1\nRETURN count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most finishes in P10 (10th place) in their career? Return driver and tens_count.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS tens_count\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 10\nGROUP BY d.driverId\nORDER BY tens_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder = 10\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver regained the championship lead most times in a season (counts of lead changes at season level)? Return driver, year, lead_changes.",
    "sql": "-- Requires round-by-round standings; use driverStandings table with round/position to count changes where position becomes 1\nSELECT d.forename || ' ' || d.surname AS driver, ds.year, COUNT() AS lead_changes\nFROM driverStandings ds\nJOIN drivers d ON d.driverId = ds.driverId\nWHERE ds.position = 1\nGROUP BY ds.driverId, ds.year\nORDER BY lead_changes DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ds:driverStandings), (ds)-[:FOR_DRIVER]->(d)\nWHERE ds.position = 1\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most podiums at non-championship events (if non-championship identify by race.type)? Fallback: none \u2014 use podiums overall.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS podiums\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY d.driverId\nORDER BY podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder <= 3\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver had the fewest retirements (percentage) in seasons where they contested at least 10 races (single season best reliability)? Return driver, year, retire_pct (3 decimals).",
    "sql": "WITH season_stats AS (\n SELECT ra.year, r.driverId, SUM(CASE WHEN s.status != 'Finished' THEN 1 ELSE 0 END) AS retires, COUNT() AS entries\n FROM results r\n JOIN races ra ON ra.raceId = r.raceId\n JOIN status s ON s.statusId = r.statusId\n GROUP BY ra.year, r.driverId\n)\nSELECT d.forename || ' ' || d.surname AS driver, ss.year, ROUND(ss.retires * 1.0 / ss.entries, 3) AS retire_pct\nFROM season_stats ss\nJOIN drivers d ON d.driverId = ss.driverId\nWHERE ss.entries >= 10\nORDER BY retire_pct ASC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nWHERE ( (exists(st.status) AND st.status <> 'Finished') OR (exists(res.status) AND res.status <> 'Finished') )\nRETURN ra.year AS year, count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most points-scoring teammates (i.e., teammates who scored points while paired with them)? Return driver and teammate_point_count.",
    "sql": "WITH teammate_pairs AS (\n SELECT r1.driverId AS driver, r2.driverId AS teammate, r2.points\n FROM results r1\n JOIN results r2 ON r1.raceId = r2.raceId AND r1.constructorId = r2.constructorId\n WHERE r1.driverId != r2.driverId\n), teammates_scored AS (\n SELECT DISTINCT driver, teammate\n FROM teammate_pairs\n WHERE teammate IN (SELECT driverId FROM results WHERE points > 0)\n)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS teammate_point_count\nFROM teammates_scored ts\nJOIN drivers d ON d.driverId = ts.driver\nGROUP BY ts.driver\nORDER BY teammate_point_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most wins in the last 5 years of the dataset (most recent 5-year window)? Return driver and wins_5yrs.",
    "sql": "-- Approx by taking MAX year then filtering last 5 years\nWITH max_year AS (SELECT MAX(year) AS my FROM races), recent AS (SELECT * FROM races WHERE year >= (SELECT my FROM max_year) - 4)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS wins_5yrs\nFROM results r\nJOIN recent ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder = 1\nGROUP BY d.driverId\nORDER BY wins_5yrs DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder = 1\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS wins\nORDER BY wins DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most podiums while driving for a single constructor (dominant pairing)? Return driver, constructor, and podiums.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, c.name AS constructor, COUNT() AS podiums\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nJOIN constructors c ON c.constructorId = r.constructorId\nWHERE r.positionOrder <= 3\nGROUP BY r.driverId, r.constructorId\nORDER BY podiums DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c)\nWHERE res.positionOrder <= 3\nRETURN count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most different podium-scoring seasons (count seasons where they had at least one podium)? Return driver and seasons_podium.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT(DISTINCT ra.year) AS seasons_podium\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY d.driverId\nORDER BY seasons_podium DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nWHERE res.positionOrder <= 3\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS podiums\nORDER BY podiums DESC\nLIMIT 1"
  },
  {
    "question": "Which constructor has the most points from fastest laps (if points allocated for fastest lap) \u2014 fallback: count fastestLap occurrences? Return constructor and fastestlap_count.",
    "sql": "SELECT c.name AS constructor, COUNT() AS fastestlap_count\nFROM results r\nJOIN constructors c ON c.constructorId = r.constructorId\nWHERE r.fastestLap > 0\nGROUP BY c.constructorId\nORDER BY fastestlap_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (c:constructors), (res)-[:BY_CONSTRUCTOR]->(c)\nRETURN c.name AS constructor, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver scored the most points in a single month (calendar month across any year)? Return driver, month, year, points_in_month.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, CAST(STRFTIME('%m', ra.date) AS INTEGER) AS month, ra.year AS year, SUM(r.points) AS points_in_month\nFROM results r\nJOIN races ra ON ra.raceId = r.raceId\nJOIN drivers d ON d.driverId = r.driverId\nGROUP BY r.driverId, ra.year, month\nORDER BY points_in_month DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d), (ra:races), (res)-[:IN_RACE]->(ra)\nRETURN sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most pole positions at night races (race name contains 'night' or 'night race')? Return driver and poles_night.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS poles_night\nFROM qualifying q\nJOIN races ra ON ra.raceId = q.raceId\nJOIN drivers d ON d.driverId = q.driverId\nWHERE q.position = 1 AND LOWER(ra.name) LIKE '%night%'\nGROUP BY q.driverId\nORDER BY poles_night DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races), (q:qualifying), (q)-[:FOR_DRIVER]->(d), (q)-[:FOR_RACE]->(ra)\nWHERE q.position = 1\nRETURN count(q) AS poles\nORDER BY poles DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the highest single-race number of pit stops (most pit stops by a driver in one race)? Return race (year, name), driver, pitstops.",
    "sql": "SELECT ra.year, ra.name AS race, d.forename || ' ' || d.surname AS driver, COUNT() AS pitstops\nFROM pitStops p\nJOIN races ra ON ra.raceId = p.raceId\nJOIN drivers d ON d.driverId = p.driverId\nGROUP BY p.raceId, p.driverId\nORDER BY pitstops DESC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (ra:races)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver recorded the most penalties (if penalties table exists) \u2014 fallback: most disqualifications/status 'Disqualified'? Return driver and dq_count.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, COUNT() AS dq_count\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nJOIN status s ON s.statusId = r.statusId\nWHERE LOWER(s.status) LIKE '%disqualif%'\nGROUP BY d.driverId\nORDER BY dq_count DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nOPTIONAL MATCH (res)-[:HAS_STATUS]->(st:status)\nRETURN d.forename + ' ' + d.surname AS driver, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which circuit has the highest average number of safety car deployments (if races table records safetyCarCount) \u2014 fallback: circuit with most races that had safety car flag? Return circuit and avg_safetycars.",
    "sql": "SELECT ci.name AS circuit, ROUND(AVG(ra.safetyCarDeployments), 2) AS avg_safetycars\nFROM races ra\nJOIN circuits ci ON ci.circuitId = ra.circuitId\nWHERE ra.safetyCarDeployments IS NOT NULL\nGROUP BY ci.circuitId\nORDER BY avg_safetycars DESC\nLIMIT 1;",
    "cypher": "MATCH (ra:races), (ci:circuits), (ra)-[:HELD_AT]->(ci)\nRETURN ci.name AS circuit, count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most points from podiums only (sum points from positions 1-3) across career? Return driver and podium_points.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, SUM(r.points) AS podium_points\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nWHERE r.positionOrder <= 3\nGROUP BY d.driverId\nORDER BY podium_points DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nWHERE res.positionOrder <= 3\nRETURN d.forename + ' ' + d.surname AS driver, sum(res.points) AS points\nORDER BY points DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the most starts without a podium? Return driver and starts_no_podium.",
    "sql": "WITH podiums AS (SELECT DISTINCT driverId FROM results WHERE positionOrder <= 3)\nSELECT d.forename || ' ' || d.surname AS driver, COUNT() AS starts_no_podium\nFROM results r\nJOIN drivers d ON d.driverId = r.driverId\nLEFT JOIN podiums p ON p.driverId = r.driverId\nWHERE p.driverId IS NULL\nGROUP BY r.driverId\nORDER BY starts_no_podium DESC\nLIMIT 1;",
    "cypher": "MATCH (res:results), (d:drivers), (res)-[:DRIVEN_BY]->(d)\nRETURN count(*) AS value\nORDER BY value DESC\nLIMIT 1"
  },
  {
    "question": "Which driver has the fastest average qualifying lap time across their career (min 30 qualifying laps)? Return driver and avg_qual_ms.",
    "sql": "SELECT d.forename || ' ' || d.surname AS driver, ROUND(AVG(q.q1_ms), 2) AS avg_qual_ms\nFROM qualifying q\nJOIN drivers d ON d.driverId = q.driverId\n-- assuming q1_ms stores milliseconds or similar field names for lap time\nGROUP BY q.driverId\nHAVING COUNT() >= 30\nORDER BY avg_qual_ms ASC\nLIMIT 1;",
    "cypher": "MATCH (d:drivers), (q:qualifying), (q)-[:FOR_DRIVER]->(d)\nRETURN count(*) AS value\nORDER BY value ASC\nLIMIT 1"
  }
]