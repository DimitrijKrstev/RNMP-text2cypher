[
  {
    "question": "Find drivers who have won more than 10 races and have also achieved pole position at least 5 times, showing their total wins and poles",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.resultId END), COUNT(DISTINCT CASE WHEN results.grid = 1 THEN results.resultId END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.resultId END) > 10 AND COUNT(DISTINCT CASE WHEN results.grid = 1 THEN results.resultId END) >= 5 ORDER BY COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.resultId END) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(r:results)-[:IN_RACE]->(race:races) WITH d, COUNT(CASE WHEN r.position = 1 THEN 1 END) AS wins, COUNT(CASE WHEN r.grid = 1 THEN 1 END) AS poles WHERE wins > 10 AND poles >= 5 RETURN d.forename, d.surname, wins, poles ORDER BY wins DESC"
  },
  {
    "question": "Which drivers have scored points in every race of a season, and in which years did they achieve this?",
    "sql": "SELECT drivers.forename, drivers.surname, races.year, COUNT(results.resultId), COUNT(DISTINCT races.raceId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId WHERE results.points > 0 GROUP BY drivers.driverId, drivers.forename, drivers.surname, races.year HAVING COUNT(DISTINCT results.raceId) = (SELECT COUNT(DISTINCT races.raceId) FROM races WHERE races.year = races.year) ORDER BY races.year DESC, drivers.surname",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races) WHERE res.points > 0 WITH d, r.year AS year, COUNT(DISTINCT r) AS racesScored MATCH (r2:races) WHERE r2.year = year WITH d, year, racesScored, COUNT(DISTINCT r2) AS totalRaces WHERE racesScored = totalRaces RETURN d.forename, d.surname, year, racesScored ORDER BY year DESC"
  },
  {
    "question": "Find the top 10 drivers by total career points who have raced for at least 3 different constructors",
    "sql": "SELECT drivers.forename, drivers.surname, SUM(results.points), COUNT(DISTINCT results.constructorId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT results.constructorId) >= 3 ORDER BY SUM(results.points) DESC LIMIT 10",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(r:results)-[:IN_RACE]->(race:races), (c:constructors)-[:ACHIEVED]->(r) WITH d, SUM(r.points) AS totalPoints, COUNT(DISTINCT c) AS numConstructors WHERE numConstructors >= 3 RETURN d.forename, d.surname, totalPoints, numConstructors ORDER BY totalPoints DESC LIMIT 10"
  },
  {
    "question": "Which drivers have won races at circuits in more than 5 different countries?",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT circuits.country) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT circuits.country) > 5 ORDER BY COUNT(DISTINCT circuits.country) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE res.position = 1 WITH d, COUNT(DISTINCT c.country) AS countries WHERE countries > 5 RETURN d.forename, d.surname, countries ORDER BY countries DESC"
  },
  {
    "question": "Find drivers who have both won a race and set the fastest lap in the same race, along with how many times they achieved this",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId), races.name FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 AND results.rank = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, races.name HAVING COUNT(results.resultId) >= 1 ORDER BY COUNT(results.resultId) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE res.position = 1 AND res.rank = 1 WITH d, COUNT(res) AS grandSlams RETURN d.forename, d.surname, grandSlams ORDER BY grandSlams DESC LIMIT 20"
  },
  {
    "question": "List drivers who improved from starting outside the top 10 to finishing on the podium, grouped by nationality with count",
    "sql": "SELECT drivers.nationality, COUNT(DISTINCT drivers.driverId), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.grid > 10 AND results.position <= 3 GROUP BY drivers.nationality HAVING COUNT(results.resultId) >= 5 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE res.grid > 10 AND res.position <= 3 WITH d.nationality AS nationality, COUNT(DISTINCT d) AS numDrivers, COUNT(res) AS recoveries WHERE recoveries >= 5 RETURN nationality, numDrivers, recoveries ORDER BY recoveries DESC"
  },
  {
    "question": "Find drivers who have won at least one race in three consecutive decades",
    "sql": "SELECT drivers.forename, drivers.surname, MIN(races.year), MAX(races.year), COUNT(DISTINCT FLOOR(races.year / 10)) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT FLOOR(races.year / 10)) >= 3 ORDER BY MIN(races.year)",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE res.position = 1 WITH d, MIN(r.year) AS firstWin, MAX(r.year) AS lastWin, COUNT(DISTINCT floor(r.year / 10)) AS decades WHERE decades >= 3 RETURN d.forename, d.surname, firstWin, lastWin, decades ORDER BY firstWin"
  },
  {
    "question": "Which British drivers have scored more than 500 career points and won races at Silverstone?",
    "sql": "SELECT drivers.forename, drivers.surname, SUM(results.points), COUNT(DISTINCT CASE WHEN circuits.circuitRef = 'silverstone' AND results.position = 1 THEN results.resultId END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE drivers.nationality = 'British' GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING SUM(results.points) > 500 AND COUNT(DISTINCT CASE WHEN circuits.circuitRef = 'silverstone' AND results.position = 1 THEN results.resultId END) > 0 ORDER BY SUM(results.points) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE d.nationality = 'British' WITH d, SUM(res.points) AS totalPoints, SUM(CASE WHEN c.circuitRef = 'silverstone' AND res.position = 1 THEN 1 ELSE 0 END) AS silverstoneWins WHERE totalPoints > 500 AND silverstoneWins > 0 RETURN d.forename, d.surname, totalPoints, silverstoneWins ORDER BY totalPoints DESC"
  },
  {
    "question": "Find drivers who have never finished on the podium but have completed more than 1000 laps in their career",
    "sql": "SELECT drivers.forename, drivers.surname, SUM(results.laps), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE drivers.driverId NOT IN (SELECT DISTINCT results.driverId FROM results WHERE results.position <= 3) GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING SUM(results.laps) > 1000 ORDER BY SUM(results.laps) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races) WHERE NOT EXISTS { MATCH (d)-[:ACHIEVED]->(podium:results) WHERE podium.position <= 3 } WITH d, SUM(res.laps) AS totalLaps, COUNT(res) AS raceCount WHERE totalLaps > 1000 RETURN d.forename, d.surname, totalLaps, raceCount ORDER BY totalLaps DESC"
  },
  {
    "question": "Identify drivers with an average finishing position better than 5 who have started at least 50 races",
    "sql": "SELECT drivers.forename, drivers.surname, AVG(results.position), COUNT(results.resultId), SUM(results.points) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position IS NOT NULL GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING AVG(results.position) < 5 AND COUNT(results.resultId) >= 50 ORDER BY AVG(results.position)",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position IS NOT NULL WITH d, AVG(res.position) AS avgPos, COUNT(res) AS raceCount, SUM(res.points) AS totalPoints WHERE avgPos < 5 AND raceCount >= 50 RETURN d.forename, d.surname, avgPos, raceCount, totalPoints ORDER BY avgPos"
  },
  {
    "question": "Which drivers have won races for multiple constructors in the same season?",
    "sql": "SELECT drivers.forename, drivers.surname, races.year, COUNT(DISTINCT results.constructorId), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, races.year HAVING COUNT(DISTINCT results.constructorId) > 1 ORDER BY races.year DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH d, r.year AS year, COUNT(DISTINCT c) AS numConstructors, COUNT(res) AS wins WHERE numConstructors > 1 RETURN d.forename, d.surname, year, numConstructors, wins ORDER BY year DESC"
  },
  {
    "question": "Find drivers who qualified on pole but did not win the race, showing the count per circuit",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.grid = 1 AND results.position != 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name HAVING COUNT(results.resultId) >= 2 ORDER BY COUNT(results.resultId) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE res.grid = 1 AND res.position <> 1 WITH d, c, COUNT(res) AS lostFromPole WHERE lostFromPole >= 2 RETURN d.forename, d.surname, c.name, lostFromPole ORDER BY lostFromPole DESC LIMIT 20"
  },
  {
    "question": "List the drivers with more than 100 race starts who have the best win percentage",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId), SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END), (SUM(CASE WHEN results.position = 1 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) * 100 FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) > 100 ORDER BY (SUM(CASE WHEN results.position = 1 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) DESC LIMIT 10",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, COUNT(res) AS totalRaces, SUM(CASE WHEN res.position = 1 THEN 1 ELSE 0 END) AS wins WHERE totalRaces > 100 RETURN d.forename, d.surname, totalRaces, wins, (toFloat(wins) / totalRaces) * 100 AS winPercentage ORDER BY winPercentage DESC LIMIT 10"
  },
  {
    "question": "Find drivers born before 1970 who won races at circuits that are still active (hosted races after 2020)",
    "sql": "SELECT drivers.forename, drivers.surname, drivers.dob, COUNT(DISTINCT circuits.circuitId), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE drivers.dob < '1970-01-01' AND results.position = 1 AND circuits.circuitId IN (SELECT DISTINCT races.circuitId FROM races WHERE races.year > 2020) GROUP BY drivers.driverId, drivers.forename, drivers.surname, drivers.dob HAVING COUNT(results.resultId) >= 1 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(c:circuits) WHERE d.dob < datetime('1970-01-01') AND res.position = 1 AND EXISTS { MATCH (r2:races)-[:HELD_AT]->(c) WHERE r2.year > 2020 } WITH d, COUNT(DISTINCT c) AS circuits, COUNT(res) AS wins RETURN d.forename, d.surname, d.dob, circuits, wins ORDER BY wins DESC"
  },
  {
    "question": "Which drivers have finished every race they started in a given season (100% finish rate) with at least 15 races?",
    "sql": "SELECT drivers.forename, drivers.surname, races.year, COUNT(results.resultId), SUM(CASE WHEN results.position IS NOT NULL THEN 1 ELSE 0 END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.statusId = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, races.year HAVING COUNT(results.resultId) >= 15 AND COUNT(results.resultId) = SUM(CASE WHEN results.statusId = 1 THEN 1 ELSE 0 END) ORDER BY races.year DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, r.year AS year, COUNT(res) AS totalRaces, SUM(CASE WHEN res.statusId = 1 THEN 1 ELSE 0 END) AS finishes WHERE totalRaces >= 15 AND totalRaces = finishes RETURN d.forename, d.surname, year, totalRaces ORDER BY year DESC"
  },
  {
    "question": "Find constructors that have won at least 50 races and have drivers from more than 10 different nationalities",
    "sql": "SELECT constructors.name, COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.resultId END), COUNT(DISTINCT drivers.nationality) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId GROUP BY constructors.constructorId, constructors.name HAVING COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.resultId END) >= 50 AND COUNT(DISTINCT drivers.nationality) > 10 ORDER BY COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.resultId END) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WITH c, SUM(CASE WHEN res.position = 1 THEN 1 ELSE 0 END) AS wins, COUNT(DISTINCT d.nationality) AS nationalities WHERE wins >= 50 AND nationalities > 10 RETURN c.name, wins, nationalities ORDER BY wins DESC"
  },
  {
    "question": "Which constructors have had at least 3 different drivers win races for them in a single season?",
    "sql": "SELECT constructors.name, races.year, COUNT(DISTINCT drivers.driverId), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId WHERE results.position = 1 GROUP BY constructors.constructorId, constructors.name, races.year HAVING COUNT(DISTINCT drivers.driverId) >= 3 ORDER BY races.year DESC, COUNT(results.resultId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH c, r.year AS year, COUNT(DISTINCT d) AS numWinners, COUNT(res) AS wins WHERE numWinners >= 3 RETURN c.name, year, numWinners, wins ORDER BY year DESC, wins DESC"
  },
  {
    "question": "Find constructors with an average grid position better than their average finishing position (meaning they tend to lose positions)",
    "sql": "SELECT constructors.name, AVG(results.grid), AVG(results.position), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.grid > 0 AND results.position IS NOT NULL GROUP BY constructors.constructorId, constructors.name HAVING AVG(results.grid) < AVG(results.position) AND COUNT(results.resultId) > 100 ORDER BY (AVG(results.position) - AVG(results.grid)) DESC LIMIT 15",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE res.grid > 0 AND res.position IS NOT NULL WITH c, AVG(res.grid) AS avgGrid, AVG(res.position) AS avgFinish, COUNT(res) AS raceCount WHERE avgGrid < avgFinish AND raceCount > 100 RETURN c.name, avgGrid, avgFinish, raceCount ORDER BY (avgFinish - avgGrid) DESC LIMIT 15"
  },
  {
    "question": "List constructors that have won the constructor championship (led standings at final race) in consecutive years",
    "sql": "SELECT constructors.name, MIN(races.year), MAX(races.year), COUNT(DISTINCT races.year) FROM constructors JOIN constructor_standings ON constructors.constructorId = constructor_standings.constructorId JOIN races ON constructor_standings.raceId = races.raceId WHERE constructor_standings.position = 1 AND races.round = (SELECT MAX(races.round) FROM races WHERE races.year = races.year) GROUP BY constructors.constructorId, constructors.name HAVING COUNT(DISTINCT races.year) >= 2 ORDER BY COUNT(DISTINCT races.year) DESC",
    "cypher": "MATCH (c:constructors)-[:HAS_STANDING]->(cs:constructor_standings), (r:races)-[:HAS_STANDING]->(cs) WHERE cs.position = 1 WITH c, r.year AS year, r.round AS round MATCH (r2:races) WHERE r2.year = year WITH c, year, round, MAX(r2.round) AS maxRound WHERE round = maxRound WITH c, COLLECT(year) AS years RETURN c.name, MIN(years), MAX(years), SIZE(years) ORDER BY SIZE(years) DESC"
  },
  {
    "question": "Which constructors have scored more than 1000 points at circuits in Europe?",
    "sql": "SELECT constructors.name, SUM(results.points), COUNT(DISTINCT circuits.circuitId), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.country IN ('UK', 'Germany', 'Italy', 'Spain', 'France', 'Belgium', 'Netherlands', 'Austria', 'Hungary', 'Monaco') GROUP BY constructors.constructorId, constructors.name HAVING SUM(results.points) > 1000 ORDER BY SUM(results.points) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits) WHERE cir.country IN ['UK', 'Germany', 'Italy', 'Spain', 'France', 'Belgium', 'Netherlands', 'Austria', 'Hungary', 'Monaco'] WITH c, SUM(res.points) AS totalPoints, COUNT(DISTINCT cir) AS numCircuits, COUNT(res) AS raceCount WHERE totalPoints > 1000 RETURN c.name, totalPoints, numCircuits, raceCount ORDER BY totalPoints DESC"
  },
  {
    "question": "Find constructors with a podium rate higher than 50% across at least 200 race entries",
    "sql": "SELECT constructors.name, COUNT(results.resultId), SUM(CASE WHEN results.position <= 3 THEN 1 ELSE 0 END), (SUM(CASE WHEN results.position <= 3 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) * 100 FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY constructors.constructorId, constructors.name HAVING COUNT(results.resultId) >= 200 AND (SUM(CASE WHEN results.position <= 3 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) > 0.5 ORDER BY (SUM(CASE WHEN results.position <= 3 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WITH c, COUNT(res) AS totalRaces, SUM(CASE WHEN res.position <= 3 THEN 1 ELSE 0 END) AS podiums WHERE totalRaces >= 200 AND toFloat(podiums) / totalRaces > 0.5 RETURN c.name, totalRaces, podiums, (toFloat(podiums) / totalRaces) * 100 AS podiumRate ORDER BY podiumRate DESC"
  },
  {
    "question": "Which British constructors have won races at more than 15 different circuits?",
    "sql": "SELECT constructors.name, COUNT(DISTINCT circuits.circuitId), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE constructors.nationality = 'British' AND results.position = 1 GROUP BY constructors.constructorId, constructors.name HAVING COUNT(DISTINCT circuits.circuitId) > 15 ORDER BY COUNT(DISTINCT circuits.circuitId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits) WHERE c.nationality = 'British' AND res.position = 1 WITH c, COUNT(DISTINCT cir) AS numCircuits, COUNT(res) AS wins WHERE numCircuits > 15 RETURN c.name, numCircuits, wins ORDER BY numCircuits DESC"
  },
  {
    "question": "Find constructors whose best qualifying position is better than their best race finish in any given year",
    "sql": "SELECT constructors.name, races.year, MIN(qualifying.position), MIN(results.position) FROM constructors JOIN qualifying ON constructors.constructorId = qualifying.constructorId JOIN results ON constructors.constructorId = results.constructorId AND qualifying.raceId = results.raceId JOIN races ON qualifying.raceId = races.raceId WHERE qualifying.position > 0 AND results.position IS NOT NULL GROUP BY constructors.constructorId, constructors.name, races.year HAVING MIN(qualifying.position) < MIN(results.position) ORDER BY races.year DESC LIMIT 30",
    "cypher": "MATCH (c:constructors)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r:races), (c)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE q.position > 0 AND res.position IS NOT NULL WITH c, r.year AS year, MIN(q.position) AS bestQual, MIN(res.position) AS bestFinish WHERE bestQual < bestFinish RETURN c.name, year, bestQual, bestFinish ORDER BY year DESC LIMIT 30"
  },
  {
    "question": "List constructors that scored points with at least 5 different drivers in a single season",
    "sql": "SELECT constructors.name, races.year, COUNT(DISTINCT drivers.driverId), SUM(results.points) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId WHERE results.points > 0 GROUP BY constructors.constructorId, constructors.name, races.year HAVING COUNT(DISTINCT drivers.driverId) >= 5 ORDER BY races.year DESC, SUM(results.points) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE res.points > 0 WITH c, r.year AS year, COUNT(DISTINCT d) AS numDrivers, SUM(res.points) AS totalPoints WHERE numDrivers >= 5 RETURN c.name, year, numDrivers, totalPoints ORDER BY year DESC, totalPoints DESC"
  },
  {
    "question": "Find constructors that have achieved pole position but never won a race at the same circuit",
    "sql": "SELECT constructors.name, circuits.name, COUNT(qualifying.qualifyId), MAX(results.position) FROM constructors JOIN qualifying ON constructors.constructorId = qualifying.constructorId JOIN races ON qualifying.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON constructors.constructorId = results.constructorId AND results.raceId = races.raceId WHERE qualifying.position = 1 GROUP BY constructors.constructorId, constructors.name, circuits.circuitId, circuits.name HAVING MIN(results.position) > 1 ORDER BY COUNT(qualifying.qualifyId) DESC LIMIT 20",
    "cypher": "MATCH (c:constructors)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE q.position = 1 WITH c, cir, COUNT(q) AS poles, MIN(res.position) AS bestFinish WHERE bestFinish > 1 RETURN c.name, cir.name, poles, bestFinish ORDER BY poles DESC LIMIT 20"
  },
  {
    "question": "Which constructors have both won races and had DNFs in more than 20% of their races?",
    "sql": "SELECT constructors.name, COUNT(results.resultId), SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END), SUM(CASE WHEN results.statusId != 1 THEN 1 ELSE 0 END), (SUM(CASE WHEN results.statusId != 1 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) * 100 FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY constructors.constructorId, constructors.name HAVING SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END) > 0 AND (SUM(CASE WHEN results.statusId != 1 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) > 0.2 ORDER BY SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END) DESC LIMIT 15",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WITH c, COUNT(res) AS totalRaces, SUM(CASE WHEN res.position = 1 THEN 1 ELSE 0 END) AS wins, SUM(CASE WHEN res.statusId <> 1 THEN 1 ELSE 0 END) AS dnfs WHERE wins > 0 AND toFloat(dnfs) / totalRaces > 0.2 RETURN c.name, totalRaces, wins, dnfs, (toFloat(dnfs) / totalRaces) * 100 AS dnfRate ORDER BY wins DESC LIMIT 15"
  },
  {
    "question": "Find the top 5 constructors by average points per race in seasons where they entered at least 10 races",
    "sql": "SELECT constructors.name, races.year, AVG(results.points), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY constructors.constructorId, constructors.name, races.year HAVING COUNT(DISTINCT races.raceId) >= 10 ORDER BY AVG(results.points) DESC LIMIT 5",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WITH c, r.year AS year, AVG(res.points) AS avgPoints, COUNT(DISTINCT r) AS raceCount WHERE raceCount >= 10 RETURN c.name, year, avgPoints, raceCount ORDER BY avgPoints DESC LIMIT 5"
  },
  {
    "question": "List constructors that have never led a race (no position 1 finishes) but have at least 100 race entries",
    "sql": "SELECT constructors.name, constructors.nationality, COUNT(results.resultId), MIN(results.position) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE constructors.constructorId NOT IN (SELECT DISTINCT results.constructorId FROM results WHERE results.position = 1) GROUP BY constructors.constructorId, constructors.name, constructors.nationality HAVING COUNT(results.resultId) >= 100 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE NOT EXISTS { MATCH (c)-[:ACHIEVED]->(win:results) WHERE win.position = 1 } WITH c, COUNT(res) AS raceCount, MIN(res.position) AS bestFinish WHERE raceCount >= 100 RETURN c.name, c.nationality, raceCount, bestFinish ORDER BY raceCount DESC"
  },
  {
    "question": "Which constructors achieved their first win at a high-altitude circuit (above 1000m)?",
    "sql": "SELECT constructors.name, circuits.name, circuits.alt, MIN(races.year) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 AND circuits.alt > 1000 GROUP BY constructors.constructorId, constructors.name, circuits.circuitId, circuits.name, circuits.alt HAVING MIN(races.year) = (SELECT MIN(races.year) FROM results JOIN races ON results.raceId = races.raceId WHERE results.constructorId = constructors.constructorId AND results.position = 1) ORDER BY MIN(races.year)",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits) WHERE res.position = 1 AND cir.alt > 1000 WITH c, cir, MIN(r.year) AS firstWinYear ORDER BY firstWinYear RETURN c.name, cir.name, cir.alt, firstWinYear LIMIT 20"
  },
  {
    "question": "Find constructors with more than 500 total laps led in their history",
    "sql": "SELECT constructors.name, SUM(results.laps), COUNT(results.resultId), SUM(results.points) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 1 GROUP BY constructors.constructorId, constructors.name HAVING SUM(results.laps) > 500 ORDER BY SUM(results.laps) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH c, SUM(res.laps) AS totalLapsLed, COUNT(res) AS wins, SUM(res.points) AS totalPoints WHERE totalLapsLed > 500 RETURN c.name, totalLapsLed, wins, totalPoints ORDER BY totalLapsLed DESC"
  },
  {
    "question": "Find circuits where more than 5 different constructors have won races and the average winning margin is under 10 seconds",
    "sql": "SELECT circuits.name, circuits.country, COUNT(DISTINCT results.constructorId), COUNT(results.resultId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING COUNT(DISTINCT results.constructorId) > 5 ORDER BY COUNT(DISTINCT results.constructorId) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(c:constructors) WHERE res.position = 1 WITH cir, COUNT(DISTINCT c) AS numConstructors, COUNT(res) AS totalWins WHERE numConstructors > 5 RETURN cir.name, cir.country, numConstructors, totalWins ORDER BY numConstructors DESC"
  },
  {
    "question": "Which circuits have hosted races in the most consecutive years?",
    "sql": "SELECT circuits.name, circuits.country, MIN(races.year), MAX(races.year), COUNT(DISTINCT races.year) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING COUNT(DISTINCT races.year) >= 20 ORDER BY COUNT(DISTINCT races.year) DESC LIMIT 15",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers) WITH cir, MIN(r.year) AS firstYear, MAX(r.year) AS lastYear, COUNT(DISTINCT r.year) AS yearsHosted WHERE yearsHosted >= 20 RETURN cir.name, cir.country, firstYear, lastYear, yearsHosted ORDER BY yearsHosted DESC LIMIT 15"
  },
  {
    "question": "Find races where the pole sitter did not finish on the podium and the winner started outside the top 5",
    "sql": "SELECT races.name, races.year, circuits.name, drivers.forename, drivers.surname, results.grid, results.position FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 1 AND results.grid > 5 AND EXISTS (SELECT 1 FROM results WHERE results.raceId = races.raceId AND results.grid = 1 AND (results.position > 3 OR results.position IS NULL)) ORDER BY races.year DESC LIMIT 20",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(winner:results)-[:IN_RACE]->(r), (poleSitter:results)-[:IN_RACE]->(r) WHERE winner.position = 1 AND winner.grid > 5 AND poleSitter.grid = 1 AND (poleSitter.position > 3 OR poleSitter.position IS NULL) RETURN r.name, r.year, cir.name, d.forename, d.surname, winner.grid ORDER BY r.year DESC LIMIT 20"
  },
  {
    "question": "List circuits with an altitude above 500m where British drivers have won at least 3 times",
    "sql": "SELECT circuits.name, circuits.country, circuits.alt, COUNT(results.resultId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE circuits.alt > 500 AND drivers.nationality = 'British' AND results.position = 1 GROUP BY circuits.circuitId, circuits.name, circuits.country, circuits.alt HAVING COUNT(results.resultId) >= 3 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers) WHERE cir.alt > 500 AND d.nationality = 'British' AND res.position = 1 WITH cir, COUNT(res) AS britishWins WHERE britishWins >= 3 RETURN cir.name, cir.country, cir.alt, britishWins ORDER BY britishWins DESC"
  },
  {
    "question": "Find circuits where Ferrari has more wins than any other constructor",
    "sql": "SELECT circuits.name, COUNT(results.resultId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE constructors.name = 'Ferrari' AND results.position = 1 GROUP BY circuits.circuitId, circuits.name HAVING COUNT(results.resultId) >= ALL (SELECT COUNT(results.resultId) FROM results JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE races.circuitId = circuits.circuitId AND results.position = 1 GROUP BY constructors.constructorId) ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(c:constructors) WHERE res.position = 1 WITH cir, c, COUNT(res) AS wins ORDER BY cir, wins DESC WITH cir, COLLECT({constructor: c.name, wins: wins})[0] AS topConstructor WHERE topConstructor.constructor = 'Ferrari' RETURN cir.name, topConstructor.wins ORDER BY topConstructor.wins DESC"
  },
  {
    "question": "Which races have had the most different winners in their history?",
    "sql": "SELECT races.name, COUNT(DISTINCT results.driverId), COUNT(DISTINCT results.constructorId), COUNT(races.raceId) FROM races JOIN results ON races.raceId = results.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 1 GROUP BY races.name HAVING COUNT(DISTINCT races.raceId) >= 10 ORDER BY COUNT(DISTINCT results.driverId) DESC LIMIT 15",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE res.position = 1 WITH r.name AS raceName, COUNT(DISTINCT d) AS uniqueWinners, COUNT(DISTINCT r) AS editions WHERE editions >= 10 RETURN raceName, uniqueWinners, editions ORDER BY uniqueWinners DESC LIMIT 15"
  },
  {
    "question": "Find circuits where the average number of finishers is less than 15",
    "sql": "SELECT circuits.name, circuits.country, AVG(finisher_count.cnt), COUNT(DISTINCT races.raceId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN (SELECT results.raceId, COUNT(results.resultId) AS cnt FROM results WHERE results.position IS NOT NULL GROUP BY results.raceId) AS finisher_count ON races.raceId = finisher_count.raceId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING AVG(finisher_count.cnt) < 15 AND COUNT(DISTINCT races.raceId) >= 5 ORDER BY AVG(finisher_count.cnt)",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results) WHERE res.position IS NOT NULL WITH cir, r, COUNT(res) AS finishers WITH cir, AVG(finishers) AS avgFinishers, COUNT(DISTINCT r) AS raceCount WHERE avgFinishers < 15 AND raceCount >= 5 RETURN cir.name, cir.country, avgFinishers, raceCount ORDER BY avgFinishers"
  },
  {
    "question": "List the races where the podium was completed by drivers from 3 different nationalities",
    "sql": "SELECT races.name, races.year, circuits.name, COUNT(DISTINCT drivers.nationality) FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position <= 3 GROUP BY races.raceId, races.name, races.year, circuits.circuitId, circuits.name HAVING COUNT(DISTINCT drivers.nationality) = 3 ORDER BY races.year DESC LIMIT 30",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE res.position <= 3 WITH r, cir, COUNT(DISTINCT d.nationality) AS nationalities WHERE nationalities = 3 RETURN r.name, r.year, cir.name ORDER BY r.year DESC LIMIT 30"
  },
  {
    "question": "Which circuits have the highest percentage of races won from pole position?",
    "sql": "SELECT circuits.name, COUNT(results.resultId), SUM(CASE WHEN results.grid = 1 AND results.position = 1 THEN 1 ELSE 0 END), (SUM(CASE WHEN results.grid = 1 AND results.position = 1 THEN 1.0 ELSE 0 END) / COUNT(DISTINCT races.raceId)) * 100 FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 1 GROUP BY circuits.circuitId, circuits.name HAVING COUNT(DISTINCT races.raceId) >= 10 ORDER BY (SUM(CASE WHEN results.grid = 1 AND results.position = 1 THEN 1.0 ELSE 0 END) / COUNT(DISTINCT races.raceId)) DESC LIMIT 10",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers) WHERE res.position = 1 WITH cir, COUNT(DISTINCT r) AS totalRaces, SUM(CASE WHEN res.grid = 1 THEN 1 ELSE 0 END) AS poleWins WHERE totalRaces >= 10 RETURN cir.name, totalRaces, poleWins, (toFloat(poleWins) / totalRaces) * 100 AS poleWinRate ORDER BY poleWinRate DESC LIMIT 10"
  },
  {
    "question": "Find circuits in countries that have produced at least one race-winning driver",
    "sql": "SELECT DISTINCT circuits.name, circuits.country, circuits.location FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE circuits.country IN (SELECT DISTINCT drivers.nationality FROM drivers JOIN results ON drivers.driverId = results.driverId WHERE results.position = 1) ORDER BY circuits.country, circuits.name",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers) WHERE EXISTS { MATCH (winner:drivers)-[:ACHIEVED]->(winRes:results) WHERE winRes.position = 1 AND winner.nationality = cir.country } RETURN DISTINCT cir.name, cir.country, cir.location ORDER BY cir.country, cir.name"
  },
  {
    "question": "Which races have had the closest finishes (based on the smallest time difference between 1st and 2nd)?",
    "sql": "SELECT races.name, races.year, circuits.name, MIN(results.milliseconds) FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 2 AND results.milliseconds IS NOT NULL GROUP BY races.raceId, races.name, races.year, circuits.circuitId, circuits.name HAVING MIN(results.milliseconds) IS NOT NULL ORDER BY MIN(results.milliseconds) LIMIT 20",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE res.position = 2 AND res.milliseconds IS NOT NULL WITH r, cir, res.milliseconds AS margin ORDER BY margin RETURN r.name, r.year, cir.name, margin LIMIT 20"
  },
  {
    "question": "Find circuits where McLaren has won more than 10 times but Ferrari has won fewer than 5 times",
    "sql": "SELECT circuits.name, SUM(CASE WHEN constructors.name = 'McLaren' THEN 1 ELSE 0 END), SUM(CASE WHEN constructors.name = 'Ferrari' THEN 1 ELSE 0 END) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 GROUP BY circuits.circuitId, circuits.name HAVING SUM(CASE WHEN constructors.name = 'McLaren' THEN 1 ELSE 0 END) > 10 AND SUM(CASE WHEN constructors.name = 'Ferrari' THEN 1 ELSE 0 END) < 5 ORDER BY SUM(CASE WHEN constructors.name = 'McLaren' THEN 1 ELSE 0 END) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(c:constructors) WHERE res.position = 1 WITH cir, SUM(CASE WHEN c.name = 'McLaren' THEN 1 ELSE 0 END) AS mclarenWins, SUM(CASE WHEN c.name = 'Ferrari' THEN 1 ELSE 0 END) AS ferrariWins WHERE mclarenWins > 10 AND ferrariWins < 5 RETURN cir.name, mclarenWins, ferrariWins ORDER BY mclarenWins DESC"
  },
  {
    "question": "List circuits with races in both the 20th and 21st centuries",
    "sql": "SELECT circuits.name, circuits.country, MIN(races.year), MAX(races.year), COUNT(DISTINCT races.raceId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING MIN(races.year) < 2000 AND MAX(races.year) >= 2000 ORDER BY COUNT(DISTINCT races.raceId) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers) WITH cir, MIN(r.year) AS firstYear, MAX(r.year) AS lastYear, COUNT(DISTINCT r) AS totalRaces WHERE firstYear < 2000 AND lastYear >= 2000 RETURN cir.name, cir.country, firstYear, lastYear, totalRaces ORDER BY totalRaces DESC"
  },
  {
    "question": "Find races where all podium finishers were from the same constructor",
    "sql": "SELECT races.name, races.year, circuits.name, constructors.name, COUNT(results.resultId) FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position <= 3 GROUP BY races.raceId, races.name, races.year, circuits.circuitId, circuits.name, constructors.constructorId, constructors.name HAVING COUNT(results.resultId) = 3 ORDER BY races.year DESC",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE res.position <= 3 WITH r, cir, c, COUNT(res) AS podiumCount WHERE podiumCount = 3 RETURN r.name, r.year, cir.name, c.name ORDER BY r.year DESC"
  },
  {
    "question": "Which circuits have hosted races where the average points scored by the winner is above 20?",
    "sql": "SELECT circuits.name, circuits.country, AVG(results.points), COUNT(DISTINCT races.raceId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 1 GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING AVG(results.points) > 20 AND COUNT(DISTINCT races.raceId) >= 5 ORDER BY AVG(results.points) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers) WHERE res.position = 1 WITH cir, AVG(res.points) AS avgWinnerPoints, COUNT(DISTINCT r) AS raceCount WHERE avgWinnerPoints > 20 AND raceCount >= 5 RETURN cir.name, cir.country, avgWinnerPoints, raceCount ORDER BY avgWinnerPoints DESC"
  },
  {
    "question": "Find drivers who have led the championship at some point but never won the title in that year",
    "sql": "SELECT DISTINCT drivers.forename, drivers.surname, races.year FROM drivers JOIN standings ON drivers.driverId = standings.driverId JOIN races ON standings.raceId = races.raceId JOIN results ON drivers.driverId = results.driverId WHERE standings.position = 1 AND drivers.driverId NOT IN (SELECT standings.driverId FROM standings JOIN races ON standings.raceId = races.raceId WHERE standings.position = 1 AND races.round = (SELECT MAX(races.round) FROM races WHERE races.year = races.year)) ORDER BY races.year DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED_STANDING]->(s:standings)<-[:IN_STANDING]-(r:races) WHERE s.position = 1 WITH d, r.year AS year, MAX(r.round) AS maxRound MATCH (d)-[:ACHIEVED_STANDING]->(finalS:standings)<-[:IN_STANDING]-(finalR:races) WHERE finalR.year = year AND finalR.round = maxRound AND finalS.position <> 1 RETURN DISTINCT d.forename, d.surname, year ORDER BY year DESC"
  },
  {
    "question": "Which drivers have scored points for different constructors in the same season at the same circuit?",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, races.year, COUNT(DISTINCT results.constructorId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.points > 0 GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name, races.year HAVING COUNT(DISTINCT results.constructorId) > 1 ORDER BY races.year DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.points > 0 WITH d, cir, r.year AS year, COUNT(DISTINCT c) AS numConstructors WHERE numConstructors > 1 RETURN d.forename, d.surname, cir.name, year, numConstructors ORDER BY year DESC"
  },
  {
    "question": "Find constructors where their drivers have achieved more than 100 combined podiums at races in Europe",
    "sql": "SELECT constructors.name, COUNT(results.resultId), COUNT(DISTINCT drivers.driverId), COUNT(DISTINCT circuits.circuitId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position <= 3 AND circuits.country IN ('UK', 'Germany', 'Italy', 'Spain', 'France', 'Belgium', 'Netherlands', 'Austria', 'Hungary', 'Monaco', 'Portugal') GROUP BY constructors.constructorId, constructors.name HAVING COUNT(results.resultId) > 100 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position <= 3 AND cir.country IN ['UK', 'Germany', 'Italy', 'Spain', 'France', 'Belgium', 'Netherlands', 'Austria', 'Hungary', 'Monaco', 'Portugal'] WITH c, COUNT(res) AS podiums, COUNT(DISTINCT d) AS numDrivers, COUNT(DISTINCT cir) AS numCircuits WHERE podiums > 100 RETURN c.name, podiums, numDrivers, numCircuits ORDER BY podiums DESC"
  },
  {
    "question": "List drivers who have won races for at least 2 constructors and achieved pole with a third constructor",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.constructorId END), COUNT(DISTINCT CASE WHEN results.grid = 1 THEN results.constructorId END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.constructorId END) >= 2 ORDER BY COUNT(DISTINCT CASE WHEN results.position = 1 THEN results.constructorId END) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, COLLECT(DISTINCT CASE WHEN res.position = 1 THEN c END) AS winConstructors, COLLECT(DISTINCT CASE WHEN res.grid = 1 THEN c END) AS poleConstructors WHERE SIZE(winConstructors) >= 2 RETURN d.forename, d.surname, SIZE(winConstructors), SIZE(poleConstructors) ORDER BY SIZE(winConstructors) DESC"
  },
  {
    "question": "Find seasons where the champion had fewer wins than a non-champion driver",
    "sql": "SELECT races.year, drivers.forename, drivers.surname, standings.position, standings.wins FROM standings JOIN drivers ON standings.driverId = drivers.driverId JOIN races ON standings.raceId = races.raceId JOIN results ON drivers.driverId = results.driverId WHERE races.round = (SELECT MAX(races.round) FROM races WHERE races.year = races.year) AND standings.position <= 2 GROUP BY races.year, drivers.driverId, drivers.forename, drivers.surname, standings.position, standings.wins ORDER BY races.year DESC, standings.position",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED_STANDING]->(s:standings)<-[:IN_STANDING]-(r:races) WHERE s.position <= 2 WITH r.year AS year, d, s, r.round AS round MATCH (r2:races) WHERE r2.year = year WITH year, d, s, round, MAX(r2.round) AS maxRound WHERE round = maxRound RETURN year, d.forename, d.surname, s.position, s.wins ORDER BY year DESC, s.position"
  },
  {
    "question": "Which driver-constructor pairs have the highest average points per race with at least 30 races together?",
    "sql": "SELECT drivers.forename, drivers.surname, constructors.name, AVG(results.points), COUNT(results.resultId), SUM(results.points) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN constructors ON results.constructorId = constructors.constructorId JOIN races ON results.raceId = races.raceId GROUP BY drivers.driverId, drivers.forename, drivers.surname, constructors.constructorId, constructors.name HAVING COUNT(results.resultId) >= 30 ORDER BY AVG(results.points) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, c, AVG(res.points) AS avgPoints, COUNT(res) AS raceCount, SUM(res.points) AS totalPoints WHERE raceCount >= 30 RETURN d.forename, d.surname, c.name, avgPoints, raceCount, totalPoints ORDER BY avgPoints DESC LIMIT 20"
  },
  {
    "question": "Find races where the constructor standings leader changed hands",
    "sql": "SELECT races.name, races.year, races.round, constructors.name, constructor_standings.position, constructor_standings.points FROM constructor_standings JOIN constructors ON constructor_standings.constructorId = constructors.constructorId JOIN races ON constructor_standings.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE constructor_standings.position = 1 ORDER BY races.year DESC, races.round",
    "cypher": "MATCH (c:constructors)-[:HAS_STANDING]->(cs:constructor_standings), (r:races)-[:HAS_STANDING]->(cs), (r)-[:HELD_AT]->(cir:circuits) WHERE cs.position = 1 RETURN r.name, r.year, r.round, c.name, cs.position, cs.points ORDER BY r.year DESC, r.round"
  },
  {
    "question": "List drivers who qualified on pole and won at circuits where the altitude is above 2000 meters",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, circuits.alt, COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN qualifying ON drivers.driverId = qualifying.driverId AND races.raceId = qualifying.raceId WHERE circuits.alt > 2000 AND results.grid = 1 AND results.position = 1 AND qualifying.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name, circuits.alt HAVING COUNT(results.resultId) >= 1 ORDER BY circuits.alt DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r) WHERE cir.alt > 2000 AND res.grid = 1 AND res.position = 1 AND q.position = 1 WITH d, cir, COUNT(res) AS wins RETURN d.forename, d.surname, cir.name, cir.alt, wins ORDER BY cir.alt DESC"
  },
  {
    "question": "Find drivers who have stood on every step of the podium at the same circuit in different years",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, COUNT(DISTINCT results.position) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position IN (1, 2, 3) GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name HAVING COUNT(DISTINCT results.position) = 3 ORDER BY circuits.name, drivers.surname",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position IN [1, 2, 3] WITH d, cir, COUNT(DISTINCT res.position) AS podiumPositions WHERE podiumPositions = 3 RETURN d.forename, d.surname, cir.name ORDER BY cir.name, d.surname"
  },
  {
    "question": "Which constructors have won at least one race in each decade from 1970 to 2020?",
    "sql": "SELECT constructors.name, COUNT(DISTINCT FLOOR(races.year / 10) * 10), COUNT(results.resultId), MIN(races.year), MAX(races.year) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position = 1 AND races.year >= 1970 AND races.year <= 2029 GROUP BY constructors.constructorId, constructors.name HAVING COUNT(DISTINCT FLOOR(races.year / 10) * 10) >= 5 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 AND r.year >= 1970 AND r.year < 2030 WITH c, COUNT(DISTINCT floor(r.year / 10) * 10) AS decades, COUNT(res) AS totalWins, MIN(r.year) AS firstWin, MAX(r.year) AS lastWin WHERE decades >= 5 RETURN c.name, decades, totalWins, firstWin, lastWin ORDER BY totalWins DESC"
  },
  {
    "question": "Find drivers who finished in the points in their debut race and went on to win a championship",
    "sql": "SELECT drivers.forename, drivers.surname, MIN(races.year), MIN(results.position) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN standings ON drivers.driverId = standings.driverId WHERE results.points > 0 AND drivers.driverId IN (SELECT DISTINCT standings.driverId FROM standings JOIN races ON standings.raceId = races.raceId WHERE standings.position = 1) GROUP BY drivers.driverId, drivers.forename, drivers.surname ORDER BY MIN(races.year)",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d)-[:ACHIEVED_STANDING]->(s:standings) WHERE res.points > 0 AND s.position = 1 WITH d, MIN(r.year) AS debutYear, MIN(res.position) AS debutPosition RETURN d.forename, d.surname, debutYear, debutPosition ORDER BY debutYear"
  },
  {
    "question": "Which circuits have been won by drivers from 10 or more different nationalities?",
    "sql": "SELECT circuits.name, circuits.country, COUNT(DISTINCT drivers.nationality), COUNT(results.resultId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING COUNT(DISTINCT drivers.nationality) >= 10 ORDER BY COUNT(DISTINCT drivers.nationality) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH cir, COUNT(DISTINCT d.nationality) AS nationalities, COUNT(res) AS wins WHERE nationalities >= 10 RETURN cir.name, cir.country, nationalities, wins ORDER BY nationalities DESC"
  },
  {
    "question": "Find the constructors that had the biggest improvement in championship position from one year to the next",
    "sql": "SELECT constructors.name, constructor_standings.position, races.year FROM constructors JOIN constructor_standings ON constructors.constructorId = constructor_standings.constructorId JOIN races ON constructor_standings.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.round = (SELECT MAX(races.round) FROM races WHERE races.year = races.year) ORDER BY constructors.name, races.year",
    "cypher": "MATCH (c:constructors)-[:HAS_STANDING]->(cs:constructor_standings), (r:races)-[:HAS_STANDING]->(cs), (r)-[:HELD_AT]->(cir:circuits) WITH c, r.year AS year, r.round AS round, cs.position AS position MATCH (r2:races) WHERE r2.year = year WITH c, year, round, position, MAX(r2.round) AS maxRound WHERE round = maxRound RETURN c.name, position, year ORDER BY c.name, year"
  },
  {
    "question": "List driver-circuit combinations where the driver has won more than 5 times",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, COUNT(results.resultId), AVG(results.grid) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name HAVING COUNT(results.resultId) > 5 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH d, cir, COUNT(res) AS wins, AVG(res.grid) AS avgGrid WHERE wins > 5 RETURN d.forename, d.surname, cir.name, wins, avgGrid ORDER BY wins DESC"
  },
  {
    "question": "Find years where the top 3 in the championship were all from different constructors",
    "sql": "SELECT races.year, COUNT(DISTINCT results.constructorId), COUNT(DISTINCT standings.driverId) FROM standings JOIN drivers ON standings.driverId = drivers.driverId JOIN races ON standings.raceId = races.raceId JOIN results ON standings.driverId = results.driverId AND races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE standings.position <= 3 AND races.round = (SELECT MAX(races.round) FROM races WHERE races.year = races.year) GROUP BY races.year HAVING COUNT(DISTINCT results.constructorId) = 3 ORDER BY races.year DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED_STANDING]->(s:standings)<-[:IN_STANDING]-(r:races), (d)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r), (c:constructors)-[:ACHIEVED]->(res) WHERE s.position <= 3 WITH r.year AS year, r.round AS round, COUNT(DISTINCT c) AS numConstructors MATCH (r2:races) WHERE r2.year = year WITH year, round, numConstructors, MAX(r2.round) AS maxRound WHERE round = maxRound AND numConstructors = 3 RETURN year ORDER BY year DESC"
  },
  {
    "question": "Find drivers whose qualifying performance (average position) is significantly better than their race performance, with at least 50 races",
    "sql": "SELECT drivers.forename, drivers.surname, AVG(qualifying.position), AVG(results.position), AVG(results.position) - AVG(qualifying.position), COUNT(DISTINCT races.raceId) FROM drivers JOIN qualifying ON drivers.driverId = qualifying.driverId JOIN results ON drivers.driverId = results.driverId AND qualifying.raceId = results.raceId JOIN races ON qualifying.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE qualifying.position > 0 AND results.position IS NOT NULL GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT races.raceId) >= 50 AND AVG(results.position) > AVG(qualifying.position) + 2 ORDER BY (AVG(results.position) - AVG(qualifying.position)) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE q.position > 0 AND res.position IS NOT NULL WITH d, AVG(q.position) AS avgQual, AVG(res.position) AS avgRace, COUNT(DISTINCT r) AS raceCount WHERE raceCount >= 50 AND avgRace > avgQual + 2 RETURN d.forename, d.surname, avgQual, avgRace, avgRace - avgQual AS positionsLost, raceCount ORDER BY positionsLost DESC LIMIT 20"
  },
  {
    "question": "Which constructors have had the most DNFs at street circuits?",
    "sql": "SELECT constructors.name, COUNT(results.resultId), COUNT(DISTINCT circuits.circuitId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN drivers ON results.driverId = drivers.driverId WHERE results.statusId != 1 AND circuits.name LIKE '%Street%' OR circuits.circuitRef IN ('monaco', 'singapore', 'baku', 'melbourne') GROUP BY constructors.constructorId, constructors.name HAVING COUNT(results.resultId) >= 10 ORDER BY COUNT(results.resultId) DESC LIMIT 15",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.statusId <> 1 AND (cir.name CONTAINS 'Street' OR cir.circuitRef IN ['monaco', 'singapore', 'baku', 'melbourne']) WITH c, COUNT(res) AS dnfs, COUNT(DISTINCT cir) AS numCircuits WHERE dnfs >= 10 RETURN c.name, dnfs, numCircuits ORDER BY dnfs DESC LIMIT 15"
  },
  {
    "question": "Find driver pairs who have been teammates at 3 or more different constructors",
    "sql": "SELECT d1.forename, d1.surname, d2.forename, d2.surname, COUNT(DISTINCT results.constructorId) FROM drivers d1 JOIN results ON d1.driverId = results.driverId JOIN results AS r2 ON results.raceId = r2.raceId AND results.constructorId = r2.constructorId AND d1.driverId < r2.driverId JOIN drivers d2 ON r2.driverId = d2.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY d1.driverId, d1.forename, d1.surname, d2.driverId, d2.forename, d2.surname HAVING COUNT(DISTINCT results.constructorId) >= 3 ORDER BY COUNT(DISTINCT results.constructorId) DESC",
    "cypher": "MATCH (d1:drivers)-[:ACHIEVED]->(res1:results)-[:IN_RACE]->(r:races), (d2:drivers)-[:ACHIEVED]->(res2:results)-[:IN_RACE]->(r), (c:constructors)-[:ACHIEVED]->(res1), (c)-[:ACHIEVED]->(res2) WHERE id(d1) < id(d2) AND res1.constructorId = res2.constructorId WITH d1, d2, COUNT(DISTINCT c) AS sharedConstructors WHERE sharedConstructors >= 3 RETURN d1.forename, d1.surname, d2.forename, d2.surname, sharedConstructors ORDER BY sharedConstructors DESC"
  },
  {
    "question": "Which drivers improved from mid-grid to podium more than 10 times in their career?",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId), AVG(results.grid), AVG(results.position) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.grid BETWEEN 10 AND 20 AND results.position <= 3 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) > 10 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.grid >= 10 AND res.grid <= 20 AND res.position <= 3 WITH d, COUNT(res) AS comebacks, AVG(res.grid) AS avgStart, AVG(res.position) AS avgFinish WHERE comebacks > 10 RETURN d.forename, d.surname, comebacks, avgStart, avgFinish ORDER BY comebacks DESC"
  },
  {
    "question": "Find races where at least 3 drivers from the same nationality finished on the podium",
    "sql": "SELECT races.name, races.year, circuits.name, drivers.nationality, COUNT(results.resultId) FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position <= 3 GROUP BY races.raceId, races.name, races.year, circuits.circuitId, circuits.name, drivers.nationality HAVING COUNT(results.resultId) >= 3 ORDER BY races.year DESC",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position <= 3 WITH r, cir, d.nationality AS nationality, COUNT(res) AS podiumCount WHERE podiumCount >= 3 RETURN r.name, r.year, cir.name, nationality, podiumCount ORDER BY r.year DESC"
  },
  {
    "question": "List constructors with at least 5 consecutive seasons of scoring points",
    "sql": "SELECT constructors.name, MIN(races.year), MAX(races.year), COUNT(DISTINCT races.year), SUM(results.points) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.points > 0 GROUP BY constructors.constructorId, constructors.name HAVING COUNT(DISTINCT races.year) >= 5 ORDER BY SUM(results.points) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WHERE res.points > 0 WITH c, MIN(r.year) AS firstYear, MAX(r.year) AS lastYear, COUNT(DISTINCT r.year) AS activeYears, SUM(res.points) AS totalPoints WHERE activeYears >= 5 RETURN c.name, firstYear, lastYear, activeYears, totalPoints ORDER BY totalPoints DESC"
  },
  {
    "question": "Find drivers who have won races in wet conditions at more than 3 different circuits",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT circuits.circuitId), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 AND results.statusId = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT circuits.circuitId) > 3 ORDER BY COUNT(DISTINCT circuits.circuitId) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH d, COUNT(DISTINCT cir) AS numCircuits, COUNT(res) AS wins WHERE numCircuits > 3 RETURN d.forename, d.surname, numCircuits, wins ORDER BY numCircuits DESC LIMIT 20"
  },
  {
    "question": "Which drivers have the highest ratio of fastest laps to race wins?",
    "sql": "SELECT drivers.forename, drivers.surname, SUM(CASE WHEN results.rank = 1 THEN 1 ELSE 0 END), SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END), CASE WHEN SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END) > 0 THEN SUM(CASE WHEN results.rank = 1 THEN 1.0 ELSE 0 END) / SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END) ELSE 0 END FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END) >= 10 ORDER BY (SUM(CASE WHEN results.rank = 1 THEN 1.0 ELSE 0 END) / SUM(CASE WHEN results.position = 1 THEN 1 ELSE 0 END)) DESC LIMIT 15",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, SUM(CASE WHEN res.rank = 1 THEN 1 ELSE 0 END) AS fastestLaps, SUM(CASE WHEN res.position = 1 THEN 1 ELSE 0 END) AS wins WHERE wins >= 10 RETURN d.forename, d.surname, fastestLaps, wins, toFloat(fastestLaps) / wins AS ratio ORDER BY ratio DESC LIMIT 15"
  },
  {
    "question": "Find circuits where there have been more than 50% first-time winners in total race history",
    "sql": "SELECT circuits.name, circuits.country, COUNT(DISTINCT races.raceId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING COUNT(DISTINCT races.raceId) >= 10 ORDER BY COUNT(DISTINCT drivers.driverId) * 1.0 / COUNT(DISTINCT races.raceId) DESC LIMIT 10",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH cir, COUNT(DISTINCT r) AS totalRaces, COUNT(DISTINCT d) AS uniqueWinners WHERE totalRaces >= 10 RETURN cir.name, cir.country, totalRaces, uniqueWinners, toFloat(uniqueWinners) / totalRaces AS winnerDiversity ORDER BY winnerDiversity DESC LIMIT 10"
  },
  {
    "question": "List drivers who scored points in their last race for each constructor they drove for",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT results.constructorId), SUM(results.points) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.points > 0 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT results.constructorId) >= 3 ORDER BY COUNT(DISTINCT results.constructorId) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WHERE res.points > 0 WITH d, COUNT(DISTINCT c) AS numConstructors, SUM(res.points) AS totalPoints WHERE numConstructors >= 3 RETURN d.forename, d.surname, numConstructors, totalPoints ORDER BY numConstructors DESC LIMIT 20"
  },
  {
    "question": "Find the average gap between qualifying and race finish positions for each constructor-driver pair",
    "sql": "SELECT drivers.forename, drivers.surname, constructors.name, AVG(results.position - qualifying.position), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN qualifying ON drivers.driverId = qualifying.driverId AND results.raceId = qualifying.raceId JOIN constructors ON results.constructorId = constructors.constructorId JOIN races ON results.raceId = races.raceId WHERE results.position IS NOT NULL AND qualifying.position > 0 GROUP BY drivers.driverId, drivers.forename, drivers.surname, constructors.constructorId, constructors.name HAVING COUNT(results.resultId) >= 20 ORDER BY AVG(results.position - qualifying.position) LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position IS NOT NULL AND q.position > 0 WITH d, c, AVG(res.position - q.position) AS avgGap, COUNT(res) AS raceCount WHERE raceCount >= 20 RETURN d.forename, d.surname, c.name, avgGap, raceCount ORDER BY avgGap LIMIT 20"
  },
  {
    "question": "Which constructors have the best qualifying record at power circuits (Monza, Spa, Silverstone)?",
    "sql": "SELECT constructors.name, AVG(qualifying.position), COUNT(qualifying.qualifyId), SUM(CASE WHEN qualifying.position = 1 THEN 1 ELSE 0 END) FROM constructors JOIN qualifying ON constructors.constructorId = qualifying.constructorId JOIN races ON qualifying.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN drivers ON qualifying.driverId = drivers.driverId WHERE circuits.circuitRef IN ('monza', 'spa', 'silverstone') GROUP BY constructors.constructorId, constructors.name HAVING COUNT(qualifying.qualifyId) >= 20 ORDER BY AVG(qualifying.position) LIMIT 10",
    "cypher": "MATCH (c:constructors)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:QUALIFIED_IN]->(q) WHERE cir.circuitRef IN ['monza', 'spa', 'silverstone'] WITH c, AVG(q.position) AS avgQualPos, COUNT(q) AS qualCount, SUM(CASE WHEN q.position = 1 THEN 1 ELSE 0 END) AS poles WHERE qualCount >= 20 RETURN c.name, avgQualPos, qualCount, poles ORDER BY avgQualPos LIMIT 10"
  },
  {
    "question": "Find drivers who have never retired from a race due to mechanical failure in at least 50 race starts",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId), SUM(results.points) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE drivers.driverId NOT IN (SELECT DISTINCT results.driverId FROM results WHERE results.statusId BETWEEN 2 AND 20) GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) >= 50 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WHERE NOT EXISTS { MATCH (d)-[:ACHIEVED]->(mechFail:results) WHERE mechFail.statusId >= 2 AND mechFail.statusId <= 20 } WITH d, COUNT(res) AS raceCount, SUM(res.points) AS totalPoints WHERE raceCount >= 50 RETURN d.forename, d.surname, raceCount, totalPoints ORDER BY raceCount DESC"
  },
  {
    "question": "List constructors whose drivers have achieved a 1-2 finish more than 20 times",
    "sql": "SELECT constructors.name, COUNT(DISTINCT races.raceId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position <= 2 GROUP BY constructors.constructorId, constructors.name, races.raceId HAVING COUNT(DISTINCT results.driverId) = 2 ORDER BY COUNT(DISTINCT races.raceId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res1:results)-[:IN_RACE]->(r:races), (c)-[:ACHIEVED]->(res2:results)-[:IN_RACE]->(r), (d1:drivers)-[:ACHIEVED]->(res1), (d2:drivers)-[:ACHIEVED]->(res2) WHERE res1.position = 1 AND res2.position = 2 AND id(d1) <> id(d2) WITH c, COUNT(DISTINCT r) AS oneTwo RETURN c.name, oneTwo ORDER BY oneTwo DESC"
  },
  {
    "question": "Find the most successful driver-constructor combinations at each circuit with at least 3 wins",
    "sql": "SELECT drivers.forename, drivers.surname, constructors.name, circuits.name, COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN constructors ON results.constructorId = constructors.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, constructors.constructorId, constructors.name, circuits.circuitId, circuits.name HAVING COUNT(results.resultId) >= 3 ORDER BY COUNT(results.resultId) DESC LIMIT 30",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH d, c, cir, COUNT(res) AS wins WHERE wins >= 3 RETURN d.forename, d.surname, c.name, cir.name, wins ORDER BY wins DESC LIMIT 30"
  },
  {
    "question": "Find drivers who have beaten their teammates in qualifying more than 70% of the time with at least 30 head-to-head comparisons",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(qualifying.qualifyId) FROM drivers JOIN qualifying ON drivers.driverId = qualifying.driverId JOIN races ON qualifying.raceId = races.raceId JOIN constructors ON qualifying.constructorId = constructors.constructorId WHERE qualifying.position < (SELECT MIN(qualifying.position) FROM qualifying WHERE qualifying.raceId = races.raceId AND qualifying.constructorId = constructors.constructorId AND qualifying.driverId != drivers.driverId) GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(qualifying.qualifyId) >= 30 ORDER BY COUNT(qualifying.qualifyId) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r:races), (c:constructors)-[:QUALIFIED_IN]->(q) WITH d, c, r, q.position AS pos MATCH (teammate:drivers)-[:QUALIFIED_IN]->(tq:qualifying)-[:FOR_RACE]->(r), (c)-[:QUALIFIED_IN]->(tq) WHERE teammate <> d WITH d, COUNT(CASE WHEN pos < tq.position THEN 1 END) AS beatTeammate, COUNT(r) AS totalComparisons WHERE totalComparisons >= 30 AND toFloat(beatTeammate) / totalComparisons > 0.7 RETURN d.forename, d.surname, beatTeammate, totalComparisons ORDER BY beatTeammate DESC LIMIT 20"
  },
  {
    "question": "Which drivers scored more points in the second half of seasons compared to the first half across their career?",
    "sql": "SELECT drivers.forename, drivers.surname, SUM(CASE WHEN races.round <= 10 THEN results.points ELSE 0 END), SUM(CASE WHEN races.round > 10 THEN results.points ELSE 0 END), SUM(CASE WHEN races.round > 10 THEN results.points ELSE 0 END) - SUM(CASE WHEN races.round <= 10 THEN results.points ELSE 0 END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING SUM(results.points) > 500 ORDER BY (SUM(CASE WHEN races.round > 10 THEN results.points ELSE 0 END) - SUM(CASE WHEN races.round <= 10 THEN results.points ELSE 0 END)) DESC LIMIT 15",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, SUM(CASE WHEN r.round <= 10 THEN res.points ELSE 0 END) AS firstHalf, SUM(CASE WHEN r.round > 10 THEN res.points ELSE 0 END) AS secondHalf, SUM(res.points) AS totalPoints WHERE totalPoints > 500 RETURN d.forename, d.surname, firstHalf, secondHalf, secondHalf - firstHalf AS difference ORDER BY difference DESC LIMIT 15"
  },
  {
    "question": "Find constructors whose points per race improved by more than 50% from one decade to the next",
    "sql": "SELECT constructors.name, FLOOR(races.year / 10) * 10, AVG(results.points), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId GROUP BY constructors.constructorId, constructors.name, FLOOR(races.year / 10) * 10 HAVING COUNT(results.resultId) >= 50 ORDER BY constructors.name, FLOOR(races.year / 10) * 10",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (d:drivers)-[:ACHIEVED]->(res) WITH c, floor(r.year / 10) * 10 AS decade, AVG(res.points) AS avgPoints, COUNT(res) AS raceCount WHERE raceCount >= 50 RETURN c.name, decade, avgPoints, raceCount ORDER BY c.name, decade"
  },
  {
    "question": "List drivers who have won races at every circuit they have podiumed at",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT CASE WHEN results.position <= 3 THEN circuits.circuitId END), COUNT(DISTINCT CASE WHEN results.position = 1 THEN circuits.circuitId END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position <= 3 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT CASE WHEN results.position <= 3 THEN circuits.circuitId END) = COUNT(DISTINCT CASE WHEN results.position = 1 THEN circuits.circuitId END) AND COUNT(DISTINCT CASE WHEN results.position = 1 THEN circuits.circuitId END) >= 3 ORDER BY COUNT(DISTINCT CASE WHEN results.position = 1 THEN circuits.circuitId END) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position <= 3 WITH d, COLLECT(DISTINCT CASE WHEN res.position <= 3 THEN cir END) AS podiumCircuits, COLLECT(DISTINCT CASE WHEN res.position = 1 THEN cir END) AS winCircuits WHERE SIZE(podiumCircuits) = SIZE(winCircuits) AND SIZE(winCircuits) >= 3 RETURN d.forename, d.surname, SIZE(podiumCircuits), SIZE(winCircuits) ORDER BY SIZE(winCircuits) DESC"
  },
  {
    "question": "Find the average points per race for drivers at circuits where they have won before vs circuits where they haven't",
    "sql": "SELECT drivers.forename, drivers.surname, AVG(CASE WHEN circuits.circuitId IN (SELECT DISTINCT races.circuitId FROM races JOIN results ON races.raceId = results.raceId WHERE results.driverId = drivers.driverId AND results.position = 1) THEN results.points ELSE NULL END), AVG(CASE WHEN circuits.circuitId NOT IN (SELECT DISTINCT races.circuitId FROM races JOIN results ON races.raceId = results.raceId WHERE results.driverId = drivers.driverId AND results.position = 1) THEN results.points ELSE NULL END) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT CASE WHEN results.position = 1 THEN circuits.circuitId END) >= 3 ORDER BY AVG(CASE WHEN circuits.circuitId IN (SELECT DISTINCT races.circuitId FROM races JOIN results ON races.raceId = results.raceId WHERE results.driverId = drivers.driverId AND results.position = 1) THEN results.points ELSE NULL END) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits) WITH d, cir, res, EXISTS { MATCH (d)-[:ACHIEVED]->(winRes:results)-[:IN_RACE]->(winR:races)-[:HELD_AT]->(cir) WHERE winRes.position = 1 } AS hasWonHere WITH d, AVG(CASE WHEN hasWonHere THEN res.points END) AS avgPointsWinCircuits, AVG(CASE WHEN NOT hasWonHere THEN res.points END) AS avgPointsOther, COUNT(DISTINCT CASE WHEN hasWonHere THEN cir END) AS winCircuitCount WHERE winCircuitCount >= 3 RETURN d.forename, d.surname, avgPointsWinCircuits, avgPointsOther ORDER BY avgPointsWinCircuits DESC LIMIT 20"
  },
  {
    "question": "Which constructors have had the most different drivers score a win for them?",
    "sql": "SELECT constructors.name, constructors.nationality, COUNT(DISTINCT drivers.driverId), COUNT(results.resultId), MIN(races.year), MAX(races.year) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY constructors.constructorId, constructors.name, constructors.nationality HAVING COUNT(DISTINCT drivers.driverId) >= 5 ORDER BY COUNT(DISTINCT drivers.driverId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH c, COUNT(DISTINCT d) AS uniqueWinners, COUNT(res) AS totalWins, MIN(r.year) AS firstWin, MAX(r.year) AS lastWin WHERE uniqueWinners >= 5 RETURN c.name, c.nationality, uniqueWinners, totalWins, firstWin, lastWin ORDER BY uniqueWinners DESC"
  },
  {
    "question": "Find drivers whose career peaked in the middle third of their total race starts",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId), SUM(results.points) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) >= 100 ORDER BY SUM(results.points) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, COUNT(res) AS totalRaces, SUM(res.points) AS totalPoints WHERE totalRaces >= 100 RETURN d.forename, d.surname, totalRaces, totalPoints ORDER BY totalPoints DESC LIMIT 20"
  },
  {
    "question": "List races where the top 5 finishers were all from different constructors",
    "sql": "SELECT races.name, races.year, circuits.name, COUNT(DISTINCT results.constructorId) FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position <= 5 GROUP BY races.raceId, races.name, races.year, circuits.circuitId, circuits.name HAVING COUNT(DISTINCT results.constructorId) = 5 ORDER BY races.year DESC",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position <= 5 WITH r, cir, COUNT(DISTINCT c) AS numConstructors WHERE numConstructors = 5 RETURN r.name, r.year, cir.name ORDER BY r.year DESC"
  },
  {
    "question": "Find drivers who have scored points in more than 80% of their race starts with at least 100 starts",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId), SUM(CASE WHEN results.points > 0 THEN 1 ELSE 0 END), (SUM(CASE WHEN results.points > 0 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) * 100 FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) >= 100 AND (SUM(CASE WHEN results.points > 0 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) > 0.8 ORDER BY (SUM(CASE WHEN results.points > 0 THEN 1.0 ELSE 0 END) / COUNT(results.resultId)) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WITH d, COUNT(res) AS totalRaces, SUM(CASE WHEN res.points > 0 THEN 1 ELSE 0 END) AS pointsRaces WHERE totalRaces >= 100 AND toFloat(pointsRaces) / totalRaces > 0.8 RETURN d.forename, d.surname, totalRaces, pointsRaces, (toFloat(pointsRaces) / totalRaces) * 100 AS pointsRate ORDER BY pointsRate DESC"
  },
  {
    "question": "Which constructor-nationality combinations have produced the most wins?",
    "sql": "SELECT constructors.name, drivers.nationality, COUNT(results.resultId), COUNT(DISTINCT drivers.driverId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY constructors.constructorId, constructors.name, drivers.nationality HAVING COUNT(results.resultId) >= 10 ORDER BY COUNT(results.resultId) DESC LIMIT 20",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH c, d.nationality AS nationality, COUNT(res) AS wins, COUNT(DISTINCT d) AS numDrivers WHERE wins >= 10 RETURN c.name, nationality, wins, numDrivers ORDER BY wins DESC LIMIT 20"
  },
  {
    "question": "Find races where the championship leader did not finish on the podium",
    "sql": "SELECT races.name, races.year, drivers.forename, drivers.surname, results.position, standings.position FROM races JOIN standings ON races.raceId = standings.raceId JOIN drivers ON standings.driverId = drivers.driverId JOIN results ON standings.driverId = results.driverId AND standings.raceId = results.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE standings.position = 1 AND (results.position > 3 OR results.position IS NULL) ORDER BY races.year DESC, races.round LIMIT 30",
    "cypher": "MATCH (r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED_STANDING]->(s:standings)<-[:IN_STANDING]-(r), (d)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WHERE s.position = 1 AND (res.position > 3 OR res.position IS NULL) RETURN r.name, r.year, d.forename, d.surname, res.position, s.position ORDER BY r.year DESC, r.round LIMIT 30"
  },
  {
    "question": "List constructors that have achieved a 1-2-3 lockout of the podium",
    "sql": "SELECT constructors.name, races.name, races.year, circuits.name FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN drivers ON results.driverId = drivers.driverId WHERE results.position <= 3 GROUP BY constructors.constructorId, constructors.name, races.raceId, races.name, races.year, circuits.circuitId, circuits.name HAVING COUNT(DISTINCT results.driverId) = 3 AND COUNT(results.resultId) = 3 ORDER BY races.year DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position <= 3 WITH c, r, cir, COUNT(DISTINCT d) AS numDrivers, COUNT(res) AS podiumCount WHERE numDrivers = 3 AND podiumCount = 3 RETURN c.name, r.name, r.year, cir.name ORDER BY r.year DESC"
  },
  {
    "question": "Find drivers who have won the most races without ever leading the championship",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 AND drivers.driverId NOT IN (SELECT DISTINCT standings.driverId FROM standings WHERE standings.position = 1) GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) >= 1 ORDER BY COUNT(results.resultId) DESC LIMIT 10",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 AND NOT EXISTS { MATCH (d)-[:ACHIEVED_STANDING]->(s:standings) WHERE s.position = 1 } WITH d, COUNT(res) AS wins RETURN d.forename, d.surname, wins ORDER BY wins DESC LIMIT 10"
  },
  {
    "question": "Which circuits have had the most different pole sitters?",
    "sql": "SELECT circuits.name, circuits.country, COUNT(DISTINCT drivers.driverId), COUNT(DISTINCT races.raceId) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN qualifying ON races.raceId = qualifying.raceId JOIN drivers ON qualifying.driverId = drivers.driverId JOIN constructors ON qualifying.constructorId = constructors.constructorId WHERE qualifying.position = 1 GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING COUNT(DISTINCT races.raceId) >= 10 ORDER BY COUNT(DISTINCT drivers.driverId) DESC LIMIT 15",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:FOR_RACE]-(q:qualifying)<-[:QUALIFIED_IN]-(d:drivers), (c:constructors)-[:QUALIFIED_IN]->(q) WHERE q.position = 1 WITH cir, COUNT(DISTINCT d) AS uniquePoleSitters, COUNT(DISTINCT r) AS totalRaces WHERE totalRaces >= 10 RETURN cir.name, cir.country, uniquePoleSitters, totalRaces ORDER BY uniquePoleSitters DESC LIMIT 15"
  },
  {
    "question": "Find the most successful qualifying-to-race conversion rate for drivers at specific circuits",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, SUM(CASE WHEN qualifying.position = 1 AND results.position = 1 THEN 1 ELSE 0 END), SUM(CASE WHEN qualifying.position = 1 THEN 1 ELSE 0 END), CASE WHEN SUM(CASE WHEN qualifying.position = 1 THEN 1 ELSE 0 END) > 0 THEN (SUM(CASE WHEN qualifying.position = 1 AND results.position = 1 THEN 1.0 ELSE 0 END) / SUM(CASE WHEN qualifying.position = 1 THEN 1 ELSE 0 END)) * 100 ELSE 0 END FROM drivers JOIN qualifying ON drivers.driverId = qualifying.driverId JOIN results ON drivers.driverId = results.driverId AND qualifying.raceId = results.raceId JOIN races ON qualifying.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name HAVING SUM(CASE WHEN qualifying.position = 1 THEN 1 ELSE 0 END) >= 3 ORDER BY (SUM(CASE WHEN qualifying.position = 1 AND results.position = 1 THEN 1.0 ELSE 0 END) / SUM(CASE WHEN qualifying.position = 1 THEN 1 ELSE 0 END)) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:QUALIFIED_IN]->(q:qualifying)-[:FOR_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r) WITH d, cir, SUM(CASE WHEN q.position = 1 AND res.position = 1 THEN 1 ELSE 0 END) AS poleWins, SUM(CASE WHEN q.position = 1 THEN 1 ELSE 0 END) AS poles WHERE poles >= 3 RETURN d.forename, d.surname, cir.name, poleWins, poles, (toFloat(poleWins) / poles) * 100 AS conversionRate ORDER BY conversionRate DESC LIMIT 20"
  },
  {
    "question": "Find seasons where a single constructor won every race",
    "sql": "SELECT races.year, constructors.name, COUNT(DISTINCT races.raceId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY races.year, constructors.constructorId, constructors.name HAVING COUNT(DISTINCT races.raceId) = (SELECT COUNT(DISTINCT races.raceId) FROM races WHERE races.year = races.year) ORDER BY races.year DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH r.year AS year, c, COUNT(DISTINCT r) AS wins MATCH (r2:races) WHERE r2.year = year WITH year, c, wins, COUNT(DISTINCT r2) AS totalRaces WHERE wins = totalRaces RETURN year, c.name, wins ORDER BY year DESC"
  },
  {
    "question": "Which drivers have the highest variance in finishing position (inconsistent performers)?",
    "sql": "SELECT drivers.forename, drivers.surname, AVG(results.position), COUNT(results.resultId), MAX(results.position) - MIN(results.position) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position IS NOT NULL GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) >= 50 ORDER BY (MAX(results.position) - MIN(results.position)) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position IS NOT NULL WITH d, AVG(res.position) AS avgPos, COUNT(res) AS raceCount, MAX(res.position) - MIN(res.position) AS posRange WHERE raceCount >= 50 RETURN d.forename, d.surname, avgPos, raceCount, posRange ORDER BY posRange DESC LIMIT 20"
  },
  {
    "question": "Find constructors that have won races in at least 4 different decades",
    "sql": "SELECT constructors.name, COUNT(DISTINCT FLOOR(races.year / 10)), MIN(races.year), MAX(races.year), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY constructors.constructorId, constructors.name HAVING COUNT(DISTINCT FLOOR(races.year / 10)) >= 4 ORDER BY COUNT(DISTINCT FLOOR(races.year / 10)) DESC, COUNT(results.resultId) DESC",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH c, COUNT(DISTINCT floor(r.year / 10)) AS decades, MIN(r.year) AS firstWin, MAX(r.year) AS lastWin, COUNT(res) AS totalWins WHERE decades >= 4 RETURN c.name, decades, firstWin, lastWin, totalWins ORDER BY decades DESC, totalWins DESC"
  },
  {
    "question": "List driver-constructor pairs that have achieved more than 30 podiums together",
    "sql": "SELECT drivers.forename, drivers.surname, constructors.name, COUNT(results.resultId), SUM(results.points) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN constructors ON results.constructorId = constructors.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position <= 3 GROUP BY drivers.driverId, drivers.forename, drivers.surname, constructors.constructorId, constructors.name HAVING COUNT(results.resultId) > 30 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position <= 3 WITH d, c, COUNT(res) AS podiums, SUM(res.points) AS totalPoints WHERE podiums > 30 RETURN d.forename, d.surname, c.name, podiums, totalPoints ORDER BY podiums DESC"
  },
  {
    "question": "Find circuits where the winner has come from the midfield (grid positions 6-15) more than 5 times",
    "sql": "SELECT circuits.name, circuits.country, COUNT(results.resultId), AVG(results.grid) FROM circuits JOIN races ON circuits.circuitId = races.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId JOIN constructors ON results.constructorId = constructors.constructorId WHERE results.position = 1 AND results.grid BETWEEN 6 AND 15 GROUP BY circuits.circuitId, circuits.name, circuits.country HAVING COUNT(results.resultId) > 5 ORDER BY COUNT(results.resultId) DESC",
    "cypher": "MATCH (cir:circuits)<-[:HELD_AT]-(r:races)<-[:IN_RACE]-(res:results)<-[:ACHIEVED]-(d:drivers), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 AND res.grid >= 6 AND res.grid <= 15 WITH cir, COUNT(res) AS midfieldWins, AVG(res.grid) AS avgWinGrid WHERE midfieldWins > 5 RETURN cir.name, cir.country, midfieldWins, avgWinGrid ORDER BY midfieldWins DESC"
  },
  {
    "question": "Which drivers have scored the most points at night races?",
    "sql": "SELECT drivers.forename, drivers.surname, SUM(results.points), COUNT(results.resultId), COUNT(DISTINCT circuits.circuitId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN constructors ON results.constructorId = constructors.constructorId WHERE circuits.circuitRef IN ('bahrain', 'singapore', 'yas_marina', 'jeddah', 'las_vegas', 'qatar') GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING SUM(results.points) > 50 ORDER BY SUM(results.points) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE cir.circuitRef IN ['bahrain', 'singapore', 'yas_marina', 'jeddah', 'las_vegas', 'qatar'] WITH d, SUM(res.points) AS totalPoints, COUNT(res) AS raceCount, COUNT(DISTINCT cir) AS numCircuits WHERE totalPoints > 50 RETURN d.forename, d.surname, totalPoints, raceCount, numCircuits ORDER BY totalPoints DESC LIMIT 20"
  },
  {
    "question": "Find the drivers with the longest gap between their first and last race win",
    "sql": "SELECT drivers.forename, drivers.surname, MIN(races.year), MAX(races.year), MAX(races.year) - MIN(races.year), COUNT(results.resultId) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId JOIN constructors ON results.constructorId = constructors.constructorId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(results.resultId) >= 5 ORDER BY (MAX(races.year) - MIN(races.year)) DESC LIMIT 15",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH d, MIN(r.year) AS firstWin, MAX(r.year) AS lastWin, COUNT(res) AS totalWins WHERE totalWins >= 5 RETURN d.forename, d.surname, firstWin, lastWin, lastWin - firstWin AS careerSpan, totalWins ORDER BY careerSpan DESC LIMIT 15"
  },
  {
    "question": "List constructors and their performance at high-speed circuits vs technical circuits",
    "sql": "SELECT constructors.name, SUM(CASE WHEN circuits.circuitRef IN ('monza', 'spa', 'silverstone', 'baku') THEN results.points ELSE 0 END), SUM(CASE WHEN circuits.circuitRef IN ('monaco', 'singapore', 'hungaroring', 'suzuka') THEN results.points ELSE 0 END), COUNT(results.resultId) FROM constructors JOIN results ON constructors.constructorId = results.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN drivers ON results.driverId = drivers.driverId GROUP BY constructors.constructorId, constructors.name HAVING COUNT(results.resultId) >= 100 ORDER BY (SUM(CASE WHEN circuits.circuitRef IN ('monza', 'spa', 'silverstone', 'baku') THEN results.points ELSE 0 END) + SUM(CASE WHEN circuits.circuitRef IN ('monaco', 'singapore', 'hungaroring', 'suzuka') THEN results.points ELSE 0 END)) DESC LIMIT 20",
    "cypher": "MATCH (c:constructors)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (d:drivers)-[:ACHIEVED]->(res) WITH c, SUM(CASE WHEN cir.circuitRef IN ['monza', 'spa', 'silverstone', 'baku'] THEN res.points ELSE 0 END) AS highSpeedPoints, SUM(CASE WHEN cir.circuitRef IN ['monaco', 'singapore', 'hungaroring', 'suzuka'] THEN res.points ELSE 0 END) AS technicalPoints, COUNT(res) AS totalRaces WHERE totalRaces >= 100 RETURN c.name, highSpeedPoints, technicalPoints, totalRaces ORDER BY highSpeedPoints + technicalPoints DESC LIMIT 20"
  },
  {
    "question": "Find drivers who have improved their championship position from one year to the next for 3 or more consecutive years",
    "sql": "SELECT drivers.forename, drivers.surname, COUNT(DISTINCT races.year), MIN(races.year), MAX(races.year) FROM drivers JOIN standings ON drivers.driverId = standings.driverId JOIN races ON standings.raceId = races.raceId JOIN results ON drivers.driverId = results.driverId JOIN constructors ON results.constructorId = constructors.constructorId GROUP BY drivers.driverId, drivers.forename, drivers.surname HAVING COUNT(DISTINCT races.year) >= 5 ORDER BY COUNT(DISTINCT races.year) DESC LIMIT 20",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED_STANDING]->(s:standings)<-[:IN_STANDING]-(r:races), (d)-[:ACHIEVED]->(res:results), (c:constructors)-[:ACHIEVED]->(res) WITH d, COUNT(DISTINCT r.year) AS yearsActive, MIN(r.year) AS firstYear, MAX(r.year) AS lastYear WHERE yearsActive >= 5 RETURN d.forename, d.surname, yearsActive, firstYear, lastYear ORDER BY yearsActive DESC LIMIT 20"
  },
  {
    "question": "Which driver-circuit-constructor combinations have produced the most wins?",
    "sql": "SELECT drivers.forename, drivers.surname, circuits.name, constructors.name, COUNT(results.resultId), MIN(races.year), MAX(races.year) FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN constructors ON results.constructorId = constructors.constructorId JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.position = 1 GROUP BY drivers.driverId, drivers.forename, drivers.surname, circuits.circuitId, circuits.name, constructors.constructorId, constructors.name HAVING COUNT(results.resultId) >= 3 ORDER BY COUNT(results.resultId) DESC LIMIT 25",
    "cypher": "MATCH (d:drivers)-[:ACHIEVED]->(res:results)-[:IN_RACE]->(r:races)-[:HELD_AT]->(cir:circuits), (c:constructors)-[:ACHIEVED]->(res) WHERE res.position = 1 WITH d, cir, c, COUNT(res) AS wins, MIN(r.year) AS firstWin, MAX(r.year) AS lastWin WHERE wins >= 3 RETURN d.forename, d.surname, cir.name, c.name, wins, firstWin, lastWin ORDER BY wins DESC LIMIT 25"
  }
]